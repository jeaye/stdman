.TH std::span::span 3 "2019.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::span::span \- std::span::span

.SH Synopsis
   constexpr span() noexcept;                                     \fB(1)\fP
   constexpr span(pointer ptr, index_type count);                 \fB(2)\fP
   constexpr span(pointer firstElem, pointer lastElem);           \fB(3)\fP
   template <std::size_t N>                                       \fB(4)\fP
   constexpr span(element_type (&arr)[N]) noexcept;
   template <std::size_t N>                                       \fB(5)\fP
   constexpr span(std::array<value_type, N>& arr) noexcept;
   template <std::size_t N>                                       \fB(6)\fP
   constexpr span(const std::array<value_type, N>& arr) noexcept;
   template <class Container>                                     \fB(7)\fP
   constexpr span(Container& cont);
   template <class Container>                                     \fB(8)\fP
   constexpr span(const Container& cont);
   template <class U, ptrdiff_t N>                                \fB(9)\fP
   constexpr span(const std::span<U, N>& s) noexcept;
   constexpr span(const span& other) noexcept = default;          \fB(10)\fP

   Constructs a span.

   1) Constructs an empty span whose data() == nullptr and size() == 0. This overload
   only participates in overload resolution if extent == 0 || extent ==
   std::dynamic_extent.
   2) Constructs a span that is a view over the range [ptr, ptr + count); the resulting
   span has data() == ptr and size() == count. The behavior is undefined if [ptr, ptr +
   count) is not a valid range or if extent != std::dynamic_extent && count != extent.
   3) Constructs a span that is a view over the range [firstElem, lastElem); equivalent
   to span(firstElem, lastElem - firstElem).
   4-6) Constructs a span that is a view over the array arr; the resulting span has
   size() == N and data() == std::data(arr). These overloads only participate in
   overload resolution if extent == std::dynamic_extent || N == extent is true and
   std::remove_pointer_t<decltype(std::data(arr))>(*)[] is convertible to element_type
   (*)[]
   7-8) Constructs a span that is a view over the range [std::data(cont),
   std::data(cont) + std::size(cont)); the resulting span has size() == std::size(cont)
   and data() == std::data(cont). The behavior is undefined if that is not a valid
   range or if extent != std::dynamic_extent && std::size(cont) != extent. These
   functions do not participate in overload resolution unless

     * Container is not a specialization of std::span, a specialization of std::array,
       or an array type;
     * std::data(cont) and std::size(cont) are both well-formed; and
     * std::remove_pointer_t<decltype(std::data(cont))>(*)[] is convertible to
       element_type (*)[].

   9) Converting constructor from another span s; the resulting span has size() ==
   s.size() and data() == s.data(). This overload only participates in overload
   resolution if extent == std::dynamic_extent || N == extent is true and U (*)[] is
   convertible to element_type (*)[].
   10) Defaulted copy constructor copies the size and data pointer; the resulting span
   has size() == other.size() and data() == other.data().

.SH Parameters

   ptr, firstElem - pointer to the first element of the sequence
   count          - number of elements in the sequence
   lastElem       - pointer past the last element of the sequence
   arr            - array to construct a view for
   cont           - container to construct a view for
   s              - another span to convert from
   other          - another span to copy from

.SH Exceptions

   2-3) Throws nothing.
   7-8) Throws what and when std::size(cont) and std::data(cont) throw.

.SH See also

   data      returns a pointer to the beginning of the sequence of elements
             \fI(public member function)\fP 
   size      returns the number of elements in the sequence
             \fI(public member function)\fP 
   operator= assigns a span
             \fI(public member function)\fP 
   size      returns the size of a container or array
   \fI(C++17)\fP   \fI(function)\fP 
   data      obtains the pointer to the underlying array
   \fI(C++17)\fP   \fI(function)\fP 
