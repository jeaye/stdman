.TH std::auto_ptr::operatorauto_ptr<Y> 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::auto_ptr::operatorauto_ptr<Y> \- std::auto_ptr::operatorauto_ptr<Y>

.SH Synopsis
   template< class Y >         \fB(1)\fP \fB(deprecated)\fP
   operator auto_ptr_ref<Y>();
   template< class Y >         \fB(2)\fP \fB(deprecated)\fP
   operator auto_ptr<Y>();

   Converts *this to an auto_ptr for a different type Y.

   1) Returns an implementation-defined type that holds a reference to *this.
   std::auto_ptr is convertible and assignable from this template. The implementation
   is allowed to provide the template with a different name or implement equivalent
   functionality in other ways.
   2) Constructs a new auto_ptr with a pointer obtained by calling release().

.SH Parameters

   \fI(none)\fP

.SH Return value

   1) An implementation-defined type that holds a reference to *this
   2) A auto_ptr with a pointer obtained by calling release().

.SH Exceptions

   \fI(none)\fP

.SH Notes

   The constructor and the copy assignment operator from auto_ptr_ref is provided to
   allow copy-constructing and assigning std::auto_ptr from nameless temporaries. Since
   its copy constructor and copy assignment operator take the argument as non-const
   reference, they cannot bind rvalue arguments directly. However, a user-defined
   conversion can be executed (which releases the original auto_ptr), followed by a
   call to the constructor or copy-assignment operator that take auto_ptr_ref by value.
   This is an early implementation of move semantics.
