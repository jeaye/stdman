.TH std::get(std::pair) 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::get(std::pair) \- std::get(std::pair)

.SH Synopsis
   Defined in header <utility>
   template< size_t I, class T1, class T2 >
                                                                (since
   typename std::tuple_element<I, std::pair<T1,T2>          \fB(1)\fP C++11)
   >::type&                                                     (until
                                                                C++14)
       get( pair<T1, T2>& p ) noexcept;
   template< size_t I, class T1, class T2 >

   constexpr std::tuple_element_t<I, std::pair<T1,T2>       \fB(1)\fP (since
   >&                                                           C++14)

       get( pair<T1, T2>& p ) noexcept;
   template< size_t I, class T1, class T2 >
                                                                        (since
   const typename std::tuple_element<I,                         \fB(2)\fP     C++11)
   std::pair<T1,T2> >::type&                                            (until
                                                                        C++14)
       get( const pair<T1,T2>& p ) noexcept;
   template< size_t I, class T1, class T2 >

   constexpr const std::tuple_element_t<I,                      \fB(2)\fP     (since
   std::pair<T1,T2> >&                                                  C++14)

       get( const pair<T1,T2>& p ) noexcept;
   template< size_t I, class T1, class T2 >
                                                                                (since
   typename std::tuple_element<I, std::pair<T1,T2>                      \fB(3)\fP     C++11)
   >::type&&                                                                    (until
                                                                                C++14)
       get( std::pair<T1,T2>&& p ) noexcept;
   template< size_t I, class T1, class T2 >             \fB(1)\fP

   constexpr std::tuple_element_t<I, std::pair<T1,T2>                   \fB(3)\fP     (since
   >&&                                                                          C++14)

       get( std::pair<T1,T2>&& p ) noexcept;
   template< size_t I, class T1, class T2 >                 \fB(2)\fP

   constexpr const std::tuple_element_t<I,                              \fB(4)\fP     (since
   std::pair<T1,T2> >&&                                                         C++17)

       get( const std::pair<T1,T2>&& p ) noexcept;
   template <class T, class U>                                  \fB(3)\fP     \fB(5)\fP     (since
   constexpr T& get(std::pair<T, U>& p) noexcept;                               C++14)
   template <class T, class U>                                                  (since
   constexpr const T& get(const std::pair<T, U>& p)                     \fB(6)\fP     C++14)
   noexcept;
   template <class T, class U>                                          \fB(7)\fP     (since
   constexpr T&& get(std::pair<T, U>&& p) noexcept;                             C++14)
   template <class T, class U>                                                  (since
   constexpr const T&& get(const std::pair<T, U>&& p)                   \fB(8)\fP     C++17)
   noexcept;
   template <class T, class U>                                          \fB(9)\fP     (since
   constexpr T& get(std::pair<U, T>& p) noexcept;                               C++14)
   template <class T, class U>                                                  (since
   constexpr const T& get(const std::pair<U, T>& p)                     \fB(10)\fP    C++14)
   noexcept;
   template <class T, class U>                                          \fB(11)\fP    (since
   constexpr T&& get(std::pair<U, T>&& p) noexcept;                             C++14)
   template <class T, class U>                                                  (since
   constexpr const T&& get(const std::pair<U, T>&& p)                   \fB(12)\fP    C++17)
   noexcept;

   Extracts an element from the pair using tuple-like interface.

   The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1.

   The type-based overloads (5-12) fail to compile if the types T and U are the same.

.SH Parameters

   p - pair whose contents to extract

.SH Return value

   1-4) Returns a reference to p.first if I==0 and a reference to p.second if I==1.
   5-8) Returns a reference to p.first.
   9-12) Returns a reference to p.second.

.SH Example

   
// Run this code

 #include <iostream>
 #include <utility>
  
 int main()
 {
     auto p = std::make_pair(1, 3.14);
     std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\\n";
     std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\\n";
 }

.SH Output:

 (1, 3.14)
 (1, 3.14)

.SH See also

   std::get(std::tuple)   tuple accesses specified element
                          \fI(function template)\fP 
   std::get(std::array)   accesses an element of an array
                          \fI(function template)\fP 
   std::get(std::variant) reads the value of the variant given the index or the type
   \fI(C++17)\fP                (if the type is unique), throws on error
                          \fI(function template)\fP 
