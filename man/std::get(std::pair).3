.TH std::get(std::pair) 3 "2022.03.29" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::get(std::pair) \- std::get(std::pair)

.SH Synopsis
   Defined in header <utility>
   template< std::size_t I, class T1, class T2
   >                                                    (since
                                                        C++11)
   typename std::tuple_element<I,                       (until
   std::pair<T1,T2> >::type&                            C++14)

   get( std::pair<T1, T2>& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >
                                                        (since
   constexpr std::tuple_element_t<I,                    C++14)
   std::pair<T1,T2> >&

   get( std::pair<T1, T2>& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >                                                            (since
                                                                C++11)
   const typename std::tuple_element<I,                         (until
   std::pair<T1,T2> >::type&                                    C++14)

   get( const std::pair<T1,T2>& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >
                                                                (since
   constexpr const std::tuple_element_t<I,                      C++14)
   std::pair<T1,T2> >&

   get( const std::pair<T1,T2>& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >                                                                    (since
                                                                        C++11)
   typename std::tuple_element<I,                                       (until
   std::pair<T1,T2> >::type&&                                           C++14)

   get( std::pair<T1,T2>&& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >
                                                                        (since
   constexpr std::tuple_element_t<I,                                    C++14)
   std::pair<T1,T2> >&&                         \fB(1)\fP

   get( std::pair<T1,T2>&& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >                                                                            (since
                                                                                C++11)
   const typename std::tuple_element<I,                                         (until
   std::pair<T1,T2> >::type&&                       \fB(2)\fP                         C++14)

   get( const std::pair<T1,T2>&& p ) noexcept;
   template< std::size_t I, class T1, class T2
   >
                                                                                (since
   constexpr const std::tuple_element_t<I,                                      C++14)
   std::pair<T1,T2> >&&                                 \fB(3)\fP

   get( const std::pair<T1,T2>&& p ) noexcept;
   template <class T, class U>                                                  (since
   constexpr T& get(std::pair<T, U>& p)                                 \fB(5)\fP     C++14)
   noexcept;
   template <class T, class U>                                                  (since
   constexpr const T& get(const std::pair<T,                    \fB(4)\fP     \fB(6)\fP     C++14)
   U>& p) noexcept;
   template <class T, class U>                                                  (since
   constexpr T&& get(std::pair<T, U>&& p)                               \fB(7)\fP     C++14)
   noexcept;
   template <class T, class U>                                                  (since
   constexpr const T&& get(const std::pair<T,                           \fB(8)\fP     C++14)
   U>&& p) noexcept;
   template <class T, class U>                                                  (since
   constexpr T& get(std::pair<U, T>& p)                                 \fB(9)\fP     C++14)
   noexcept;
   template <class T, class U>                                                  (since
   constexpr const T& get(const std::pair<U,                            \fB(10)\fP    C++14)
   T>& p) noexcept;
   template <class T, class U>                                                  (since
   constexpr T&& get(std::pair<U, T>&& p)                               \fB(11)\fP    C++14)
   noexcept;
   template <class T, class U>                                                  (since
   constexpr const T&& get(const std::pair<U,                           \fB(12)\fP    C++14)
   T>&& p) noexcept;

   Extracts an element from the pair using tuple-like interface.

   The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1.

   The type-based overloads (5-12) fail to compile if the types T and U are the same.

.SH Parameters

   p - pair whose contents to extract

.SH Return value

   1-4) Returns a reference to p.first if I==0 and a reference to p.second if I==1.
   5-8) Returns a reference to p.first.
   9-12) Returns a reference to p.second.

.SH Example


// Run this code

 #include <iostream>
 #include <utility>

 int main()
 {
     auto p = std::make_pair(1, 3.14);
     std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\\n";
     std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\\n";
 }

.SH Output:

 (1, 3.14)
 (1, 3.14)

  Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR       Applied to          Behavior as published           Correct behavior
   LWG 2485 C++11 (by index) there are no overloads for const   the overloads are added
            C++14 (by type)  pair&&

.SH See also

   Structured binding \fI(C++17)\fP binds the specified names to sub-objects or tuple
                              elements of the initializer
   std::get(std::tuple)       tuple accesses specified element
   \fI(C++11)\fP                    \fI(function template)\fP
   std::get(std::array)       accesses an element of an array
   \fI(C++11)\fP                    \fI(function template)\fP
   std::get(std::variant)     reads the value of the variant given the index or the
   \fI(C++17)\fP                    type (if the type is unique), throws on error
                              \fI(function template)\fP
   get(std::ranges::subrange) obtains iterator or sentinel from a std::ranges::subrange
   (C++20)                    \fI(function template)\fP
