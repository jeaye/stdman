.TH std::experimental::ranges::CopyConstructible 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::CopyConstructible \- std::experimental::ranges::CopyConstructible

.SH Synopsis
   Defined in header <experimental/ranges/concepts>
   template <class T>

   concept bool CopyConstructible =
     ranges::MoveConstructible<T> &&
     ranges::Constructible<T, T&> && ranges::ConvertibleTo<T&, T> &&        (ranges TS)
     ranges::Constructible<T, const T&> && ranges::ConvertibleTo<const T&,
   T> &&

     ranges::Constructible<T, const T> && ranges::ConvertibleTo<const T,
   T>;

   The concept CopyConstructible is satisfied if T is an lvalue reference type, or if
   it is a MoveConstructible object type where an object of that type can constructed
   from a (possibly const) lvalue or const rvalue of that type in both direct- and
   copy-initialization contexts with the usual semantics (a copy is constructed with
   the source unchanged).

   More precisely, if T is an object type, then CopyConstructible<T> is satisfied only
   if given

     * v, a lvalue of type (possibly const) T or an rvalue of type const T,

   the following are true:

     * After the definition T u = v;, u is equal to v;
     * T{v} is equal to v.

.SH See also

   is_copy_constructible
   is_trivially_copy_constructible
   is_nothrow_copy_constructible   checks if a type has a copy constructor
   \fI(C++11)\fP                         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
