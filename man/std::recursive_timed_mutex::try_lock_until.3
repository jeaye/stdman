.TH std::recursive_timed_mutex::try_lock_until 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::recursive_timed_mutex::try_lock_until \- std::recursive_timed_mutex::try_lock_until

.SH Synopsis
   template< class Clock, class Duration >
   bool try_lock_until( const std::chrono::time_point<Clock,Duration>&    \fI(since C++11)\fP
   timeout_time );

   Tries to lock the mutex. Blocks until specified timeout_time has been reached or the
   lock is acquired, whichever comes first. On successful lock acquisition returns
   true, otherwise returns false.

   If timeout_time has already passed, this function behaves like try_lock().

   The clock tied to timeout_time is used, which means that adjustments of the clock
   are taken into account. Thus, the maximum duration of the block might, but might
   not, be less or more than timeout_time - Clock::now() at the time of the call,
   depending on the direction of the adjustment. The function also may block for longer
   than until after timeout_time has been reached due to scheduling or resource
   contention delays.

   As with try_lock(), this function is allowed to fail spuriously and return false
   even if the mutex was not locked by any other thread at some point before
   timeout_time.

   Prior unlock() operation on the same mutex synchronizes-with (as defined in
   std::memory_order) this operation if it returns true.

   A thread may call try_lock_until on a recursive mutex repeatedly. Successful calls
   to try_lock_until increment the ownership count: the mutex will only be released
   after the thread makes a matching number of calls to unlock.

   The maximum number of levels of ownership is unspecified. A call to try_lock_until
   will return false if this number is exceeded.

.SH Parameters

   timeout_time - maximum time point to block until

.SH Return value

   true if the lock was acquired successfully, otherwise false.

.SH Exceptions

   Any exception thrown by clock, time_point, or duration during the execution (clocks,
   time points, and durations provided by the standard library never throw)

.SH Example

   This example shows a 10 seconds block

   
// Run this code

 #include <thread>
 #include <iostream>
 #include <chrono>
 #include <mutex>
  
 std::recursive_timed_mutex test_mutex;
  
 void f()
 {
     auto now=std::chrono::steady_clock::now();
     test_mutex.try_lock_until(now + std::chrono::seconds(10));
     std::cout << "hello world\\n";
 }
  
 int main()
 {
     std::lock_guard<std::recursive_timed_mutex> l(test_mutex);
     std::thread t(f);
     t.join();
 }

.SH See also

   lock         locks the mutex, blocks if the mutex is not available
                \fI(public member function)\fP 
   try_lock     tries to lock the mutex, returns if the mutex is not available
                \fI(public member function)\fP 
                tries to lock the mutex, returns if the mutex has been
   try_lock_for unavailable for the specified timeout duration
                \fI(public member function)\fP 
   unlock       unlocks the mutex
                \fI(public member function)\fP 
   C documentation for
   mtx_timedlock
