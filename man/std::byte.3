.TH std::byte 3 "2019.08.27" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::byte \- std::byte

.SH Synopsis
   Defined in header <cstddef>
   enum class byte : unsigned char {} ;  \fI(since C++17)\fP

   std::byte is a distinct type that implements the concept of byte as specified in the
   C++ language definition.

   Like char and unsigned char, it can be used to access raw memory occupied by other
   objects (object representation), but unlike those types, it is not a character type
   and is not an arithmetic type. A byte is only a collection of bits, and the only
   operators defined for it are the bitwise ones.

.SH Non-member functions

std::to_integer

   template <class IntegerType>                             \fI(since C++17)\fP
   constexpr IntegerType to_integer(std::byte b) noexcept;

   Equivalent to: return IntegerType(b); This overload only participates in overload
   resolution if std::is_integral_v<IntegerType> is true.

std::operator<<=,operator>>=

   template <class IntegerType>
   constexpr std::byte& operator<<=(std::byte& b, IntegerType shift)  \fB(1)\fP \fI(since C++17)\fP
   noexcept;
   template <class IntegerType>
   constexpr std::byte& operator>>=(std::byte& b, IntegerType shift)  \fB(2)\fP \fI(since C++17)\fP
   noexcept;

   1) Equivalent to: return b = b << shift; This overload only participates in overload
   resolution if std::is_integral_v<IntegerType> is true.
   2) Equivalent to: return b = b >> shift;

   This overload only participates in overload resolution if
   std::is_integral_v<IntegerType> is true.

std::operator<<,operator>>

   template <class IntegerType>
   constexpr std::byte operator <<(std::byte b, IntegerType shift)    \fB(1)\fP \fI(since C++17)\fP
   noexcept;
   template <class IntegerType>
   constexpr std::byte operator >>(std::byte b, IntegerType shift)    \fB(2)\fP \fI(since C++17)\fP
   noexcept;

   1) Equivalent to: return std::byte(static_cast<unsigned int>(b) << shift); This
   overload only participates in overload resolution if std::is_integral_v<IntegerType>
   is true.
   2) Equivalent to: return std::byte(static_cast<unsigned int>(b) >> shift);

   This overload only participates in overload resolution if
   std::is_integral_v<IntegerType> is true.

std::operator|=,operator&=,operator^=

   constexpr std::byte& operator|=(std::byte& l, std::byte r)         \fB(1)\fP \fI(since C++17)\fP
   noexcept;
   constexpr std::byte& operator&=(std::byte& l, std::byte r)         \fB(2)\fP \fI(since C++17)\fP
   noexcept;
   constexpr std::byte& operator^=(std::byte& l, std::byte r)         \fB(3)\fP \fI(since C++17)\fP
   noexcept;

   1) Equivalent to: return l = l | r;.
   2) Equivalent to: return l = l & r;.
   3) Equivalent to: return l = l ^ r;.

std::operator|,operator&,operator^,operator~

   constexpr std::byte operator|(std::byte l, std::byte r) noexcept; \fB(1)\fP \fI(since C++17)\fP
   constexpr std::byte operator&(std::byte l, std::byte r) noexcept; \fB(2)\fP \fI(since C++17)\fP
   constexpr std::byte operator^(std::byte l, std::byte r) noexcept; \fB(3)\fP \fI(since C++17)\fP
   constexpr std::byte operator~(std::byte b) noexcept;              \fB(4)\fP \fI(since C++17)\fP

   1) Equivalent to: return std::byte(static_cast<unsigned int>(l) |
   static_cast<unsigned int>(r));.
   2) Equivalent to: return std::byte(static_cast<unsigned int>(l) &
   static_cast<unsigned int>(r));.
   3) Equivalent to: return std::byte(static_cast<unsigned int>(l) ^
   static_cast<unsigned int>(r));.
   4) Equivalent to: return std::byte(~static_cast<unsigned int>(b));

.SH Notes

   A numeric value n can be converted to a byte value using std::byte{n}, due to C++17
   relaxed enum class initialization rules.

   A byte can be converted to a numeric value (such as to produce an integer hash of an
   object) using std::to_integer.

.SH Example

    This section is incomplete
    Reason: no example
