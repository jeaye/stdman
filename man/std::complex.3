.TH std::complex 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::complex \- std::complex

.SH Synopsis
   Defined in header <complex>
   template< class T >                    \fB(1)\fP
   class complex;
   template<> class complex<float>;       \fB(2)\fP
   template<> class complex<double>;      \fB(3)\fP
   template<> class complex<long double>; \fB(4)\fP

   The specializations std::complex<float>, std::complex<double>, and std::complex<long
   double> are LiteralTypes for representing and manipulating complex numbers.

   The effect of instantiating the template complex for any other type is unspecified.

.SH Member types

   Member type Definition
   value_type  T

.SH Member functions

   constructor   constructs a complex number
                 \fI(public member function)\fP 
   operator=     assigns the contents
                 \fI(public member function)\fP 
   real          accesses the real part of the complex number
                 \fI(public member function)\fP 
   imag          accesses the imaginary part of the complex number
                 \fI(public member function)\fP 
   operator+=
   operator-=    compound assignment of two complex numbers or a complex and a scalar
   operator/=    \fI(public member function)\fP 
   operator*=

.SH Non-member functions

   operator+           applies unary operators to complex numbers
   operator-           \fI(function template)\fP 
   operator+           performs complex number arithmetics on two complex values or a
   operator-           complex and a scalar
   operator*           \fI(function template)\fP 
   operator/
   operator==          compares two complex numbers or a complex and a scalar
   operator!=          \fI(function template)\fP 
   operator<<          serializes and deserializes a complex number
   operator>>          \fI(function template)\fP 
   real                returns the real component
                       \fI(function template)\fP 
   imag                returns the imaginary component
                       \fI(function template)\fP 
   abs(std::complex)   returns the magnitude of a complex number
                       \fI(function template)\fP 
   arg                 returns the phase angle
                       \fI(function template)\fP 
   norm                returns the squared magnitude
                       \fI(function template)\fP 
   conj                returns the complex conjugate
                       \fI(function template)\fP 
   proj                returns the projection onto the Riemann sphere
   \fI(C++11)\fP             \fI(function template)\fP 
   polar               constructs a complex number from magnitude and phase angle
                       \fI(function template)\fP 
.SH Exponential functions
   exp(std::complex)   complex base e exponential
                       \fI(function template)\fP 
                       complex natural logarithm with the branch cuts along the
   log(std::complex)   negative real axis
                       \fI(function template)\fP 
                       complex common logarithm with the branch cuts along the negative
   log10(std::complex) real axis
                       \fI(function template)\fP 
.SH Power functions
   pow(std::complex)   complex power, one or both arguments may be a complex number
                       \fI(function template)\fP 
   sqrt(std::complex)  complex square root in the range of the right half-plane
                       \fI(function template)\fP 
.SH Trigonometric functions
   sin(std::complex)   computes sine of a complex number (sin(z))
                       \fI(function template)\fP 
   cos(std::complex)   computes cosine of a complex number (cos(z))
                       \fI(function template)\fP 
   tan(std::complex)   computes tangent of a complex number (tan(z))
                       \fI(function template)\fP 
   asin(std::complex)  computes arc sine of a complex number (arcsin(z))
   \fI(C++11)\fP             \fI(function template)\fP 
   acos(std::complex)  computes arc cosine of a complex number (arccos(z))
   \fI(C++11)\fP             \fI(function template)\fP 
   atan(std::complex)  computes arc tangent of a complex number (arctan(z))
   \fI(C++11)\fP             \fI(function template)\fP 
.SH Hyperbolic functions
   sinh(std::complex)  computes hyperbolic sine of a complex number (sh(z))
                       \fI(function template)\fP 
   cosh(std::complex)  computes hyperbolic cosine of a complex number (ch(z))
                       \fI(function template)\fP 
   tanh(std::complex)  computes hyperbolic tangent of a complex number
                       \fI(function template)\fP 
   asinh(std::complex) computes area hyperbolic sine of a complex number
   \fI(C++11)\fP             \fI(function template)\fP 
   acosh(std::complex) computes area hyperbolic cosine of a complex number
   \fI(C++11)\fP             \fI(function template)\fP 
   atanh(std::complex) computes area hyperbolic tangent of a complex number
   \fI(C++11)\fP             \fI(function template)\fP 

.SH Non-static data members

   For any object z of type complex<T>, reinterpret_cast<T(&)[2]>(z)[0]
   is the real part of z and reinterpret_cast<T(&)[2]>(z)[1] is the
   imaginary part of z.

   For any pointer to an element of an array of complex<T> named p and
   any valid array index i, reinterpret_cast<T*>(p)[2*i] is the real part
   of the complex number p[i], and reinterpret_cast<T*>(p)[2*i + 1] is
   the imaginary part of the complex number p[i]

   These requirements essentially limit implementation of each of the     \fI(since C++11)\fP
   three specializations of std::complex to declaring two and only two
   non-static data members, of type value_type, with the same member
   access, which hold the real and the imaginary components,
   respectively.

   The intent of this requirement is to preserve binary compatibility
   between the C++ library complex number types and the C language
   complex number types (and arrays thereof), which have an identical
   object representation requirement.

.SH Literals

   Defined in inline namespace std::literals::complex_literals
   operator""if
   operator""i    A std::complex literal representing pure imaginary number
   operator""il   \fI(function)\fP 
   \fI(C++14)\fP

.SH Example

   
// Run this code

 #include <iostream>
 #include <iomanip>
 #include <complex>
 #include <cmath>
  
 int main()
 {
     using namespace std::complex_literals;
     std::cout << std::fixed << std::setprecision(1);
  
     std::complex<double> z1 = 1i * 1i;     // imaginary unit squared
     std::cout << "i * i = " << z1 << '\\n';
  
     std::complex<double> z2 = std::pow(1i, 2); // imaginary unit squared
     std::cout << "pow(i, 2) = " << z2 << '\\n';
  
     double PI = std::acos(-1);
     std::complex<double> z3 = std::exp(1i * PI); // Euler's formula
     std::cout << "exp(i * pi) = " << z3 << '\\n';
  
     std::complex<double> z4 = 1. + 2i, z5 = 1. - 2i; // conjugates
     std::cout << "(1+2i)*(1-2i) = " << z4*z5 << '\\n';
 }

.SH Output:

 i * i = (-1.0,0.0)
 pow(i, 2) = (-1.0,0.0)
 exp(i * pi) = (-1.0,0.0)
 (1+2i)*(1-2i) = (5.0,0.0)

.SH See also

   C documentation for
   Complex number arithmetic
