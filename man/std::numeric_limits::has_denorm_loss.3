.TH std::numeric_limits::has_denorm_loss 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::has_denorm_loss \- std::numeric_limits::has_denorm_loss

.SH Synopsis
   static const bool has_denorm_loss;      \fI(until C++11)\fP
   static constexpr bool has_denorm_loss;  \fI(since C++11)\fP

   The value of std::numeric_limits<T>::has_denorm_loss is true for all floating-point
   types T that detect loss of precision when creating a subnormal number as
   denormalization loss rather than as inexact result (see below).

.SH Standard specializations

   T                     value of std::numeric_limits<T>::has_denorm_loss
   /* non-specialized */ false
   bool                  false
   char                  false
   signed char           false
   unsigned char         false
   wchar_t               false
   char16_t              false
   char32_t              false
   short                 false
   unsigned short        false
   int                   false
   unsigned int          false
   long                  false
   unsigned long         false
   long long             false
   unsigned long long    false
   float                 implementation-defined
   double                implementation-defined
   long double           implementation-defined

.SH Notes

   Standard-compliant IEEE 754 floating-point implementations of subnormal numbers are
   required to detect the loss of accuracy associated with the creation of such number,
   if it occurs, and may do so in one of the two distinct ways:

   1) Denormalization loss: the delivered result differs from what would have been
   computed were exponent range unbounded.
   2) Inexact result: the delivered result differs from what would have been computed
   were both exponent range and precision unbounded.

   No implementation of denormalization loss mechanism exists (accuracy loss is
   detected after rounding, as inexact result), and this option was removed in the 2008
   revision of IEEE Std 754.

   libstdc++, libc++, libCstd, and stlport4 define this constant as false for all
   floating-point types. Microsoft Visual Studio defines it as true for all
   floating-point types.

   As with any floating-point computations, accuracy loss may raise FE_INEXACT

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   tinyness_before identifies floating-point types that detect tinyness before rounding
   \fB[static]\fP        \fI(public static member constant)\fP 
   has_denorm      identifies the denormalization style used by the floating-point type
   \fB[static]\fP        \fI(public static member constant)\fP 

.SH Category:

     * Todo no example
