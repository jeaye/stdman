.TH std::numeric_limits 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits \- std::numeric_limits

.SH Synopsis
   Defined in header <limits>
   template< class T > class numeric_limits;

   The numeric_limits class template provides a standardized way to query various
   properties of arithmetic types (e.g. the largest possible value for type int is
   std::numeric_limits<int>::max()).

   This information is provided via specializations of the numeric_limits template. The
   standard library makes available specializations for all arithmetic types:

   Defined in header <limits>
   template<> class numeric_limits<bool>;
   template<> class numeric_limits<char>;
   template<> class numeric_limits<signed char>;
   template<> class numeric_limits<unsigned char>;
   template<> class numeric_limits<wchar_t>;
   template<> class numeric_limits<char8_t>;             \fI(since C++20)\fP
   template<> class numeric_limits<char16_t>;            \fI(since C++11)\fP
   template<> class numeric_limits<char32_t>;            \fI(since C++11)\fP
   template<> class numeric_limits<short>;
   template<> class numeric_limits<unsigned short>;
   template<> class numeric_limits<int>;
   template<> class numeric_limits<unsigned int>;
   template<> class numeric_limits<long>;
   template<> class numeric_limits<unsigned long>;
   template<> class numeric_limits<long long>;           \fI(since C++11)\fP
   template<> class numeric_limits<unsigned long long>;  \fI(since C++11)\fP
   template<> class numeric_limits<float>;
   template<> class numeric_limits<double>;
   template<> class numeric_limits<long double>;

   Additionally, a specialization exists for every cv-qualified version of each
   cv-unqualified type for which the specialization exists, identical to the
   unqualified specialization, e.g. std::numeric_limits<const int>,
   std::numeric_limits<volatile int>, and std::numeric_limits<const volatile int> are
   provided and are equivalent to std::numeric_limits<int>.

   Aliases of arithmetic types (such as std::size_t or std::streamsize) may also be
   examined with the std::numeric_limits type traits.

   Non-arithmetic standard types, such as std::complex<T> or std::nullptr_t, do not
   have specializations.

   If the implementation defines any integer-class types, specializations \fI(since C++20)\fP
   of std::numeric_limits must also be provided for them.

   Implementations may provide specializations of std::numeric_limits for
   implementation-specific types: e.g. GCC provides std::numeric_limits<__int128>.
   Non-standard libraries may add specializations for library-provided types, e.g.
   OpenEXR provides std::numeric_limits<half> for a 16-bit floating-point type.

.SH Template parameters

   T - a type to retrieve numeric properties for

.SH Member constants

   is_specialized    identifies types for which std::numeric_limits is specialized
   \fB[static]\fP          \fI(public static member constant)\fP
   is_signed         identifies signed types
   \fB[static]\fP          \fI(public static member constant)\fP
   is_integer        identifies integer types
   \fB[static]\fP          \fI(public static member constant)\fP
   is_exact          identifies exact types
   \fB[static]\fP          \fI(public static member constant)\fP
   has_infinity      identifies floating-point types that can represent the special
   \fB[static]\fP          value "positive infinity"
                     \fI(public static member constant)\fP
   has_quiet_NaN     identifies floating-point types that can represent the special
   \fB[static]\fP          value "quiet not-a-number" (NaN)
                     \fI(public static member constant)\fP
   has_signaling_NaN identifies floating-point types that can represent the special
   \fB[static]\fP          value "signaling not-a-number" (NaN)
                     \fI(public static member constant)\fP
   has_denorm        identifies the denormalization style used by the floating-point
   \fB[static]\fP          type
                     \fI(public static member constant)\fP
   has_denorm_loss   identifies the floating-point types that detect loss of precision
   \fB[static]\fP          as denormalization loss rather than inexact result
                     \fI(public static member constant)\fP
   round_style       identifies the rounding style used by the type
   \fB[static]\fP          \fI(public static member constant)\fP
   is_iec559         identifies the IEC 559/IEEE 754 floating-point types
   \fB[static]\fP          \fI(public static member constant)\fP
   is_bounded        identifies types that represent a finite set of values
   \fB[static]\fP          \fI(public static member constant)\fP
   is_modulo         identifies types that handle overflows with modulo arithmetic
   \fB[static]\fP          \fI(public static member constant)\fP
   digits            number of radix digits that can be represented without change
   \fB[static]\fP          \fI(public static member constant)\fP
   digits10          number of decimal digits that can be represented without change
   \fB[static]\fP          \fI(public static member constant)\fP
   max_digits10      number of decimal digits necessary to differentiate all values of
   \fB[static]\fP \fI(C++11)\fP  this type
                     \fI(public static member constant)\fP
   radix             the radix or integer base used by the representation of the given
   \fB[static]\fP          type
                     \fI(public static member constant)\fP
   min_exponent      one more than the smallest negative power of the radix that is a
   \fB[static]\fP          valid normalized floating-point value
                     \fI(public static member constant)\fP
   min_exponent10    the smallest negative power of ten that is a valid normalized
   \fB[static]\fP          floating-point value
                     \fI(public static member constant)\fP
   max_exponent      one more than the largest integer power of the radix that is a
   \fB[static]\fP          valid finite floating-point value
                     \fI(public static member constant)\fP
   max_exponent10    the largest integer power of 10 that is a valid finite
   \fB[static]\fP          floating-point value
                     \fI(public static member constant)\fP
   traps             identifies types which can cause arithmetic operations to trap
   \fB[static]\fP          \fI(public static member constant)\fP
   tinyness_before   identifies floating-point types that detect tinyness before
   \fB[static]\fP          rounding
                     \fI(public static member constant)\fP

.SH Member functions

   min              returns the smallest finite value of the given type
   \fB[static]\fP         \fI(public static member function)\fP
   lowest           returns the lowest finite value of the given type
   \fB[static]\fP \fI(C++11)\fP \fI(public static member function)\fP
   max              returns the largest finite value of the given type
   \fB[static]\fP         \fI(public static member function)\fP
   epsilon          returns the difference between 1.0 and the next representable value
   \fB[static]\fP         of the given floating-point type
                    \fI(public static member function)\fP
   round_error      returns the maximum rounding error of the given floating-point type
   \fB[static]\fP         \fI(public static member function)\fP
   infinity         returns the positive infinity value of the given floating-point
   \fB[static]\fP         type
                    \fI(public static member function)\fP
   quiet_NaN        returns a quiet NaN value of the given floating-point type
   \fB[static]\fP         \fI(public static member function)\fP
   signaling_NaN    returns a signaling NaN value of the given floating-point type
   \fB[static]\fP         \fI(public static member function)\fP
   denorm_min       returns the smallest positive subnormal value of the given
   \fB[static]\fP         floating-point type
                    \fI(public static member function)\fP

.SH Helper classes

   float_round_style  indicates floating-point rounding modes
                      \fI(enum)\fP
   float_denorm_style indicates floating-point denormalization modes
                      \fI(enum)\fP

.SH Relationship with C library macro constants

       Specialization                          Members
   std::numeric_limits<T>   min()   lowest()       max()       radix
         where T is                  \fI(C++11)\fP
   bool                   false     false     true             2
   char                   CHAR_MIN  CHAR_MIN  CHAR_MAX         2
   signed char            SCHAR_MIN SCHAR_MIN SCHAR_MAX        2
   unsigned char          0   0   UCHAR_MAX        2
   wchar_t                WCHAR_MIN WCHAR_MIN WCHAR_MAX        2
   char8_t                0   0   UCHAR_MAX        2
   char16_t               0   0   UINT_LEAST16_MAX 2
   char32_t               0   0   UINT_LEAST32_MAX 2
   short                  SHRT_MIN  SHRT_MIN  SHRT_MAX         2
   signed short
   unsigned short         0   0   USHRT_MAX        2
   int                    INT_MIN   INT_MIN   INT_MAX          2
   signed int
   unsigned int           0   0   UINT_MAX         2
   long                   LONG_MIN  LONG_MIN  LONG_MAX         2
   signed long
   unsigned long          0   0   ULONG_MAX        2
   long long              LLONG_MIN LLONG_MIN LLONG_MAX        2
   signed long long
   unsigned long long     0   0   ULLONG_MAX       2

    Specialization                                          Members
std::numeric_limits<T> denorm_min()   min()   lowest()   max()    epsilon()      digits     digits10
      where T is                               \fI(C++11)\fP
float                  FLT_TRUE_MIN  FLT_MIN  -FLT_MAX  FLT_MAX  FLT_EPSILON  FLT_MANT_DIG  FLT_DIG
double                 DBL_TRUE_MIN  DBL_MIN  -DBL_MAX  DBL_MAX  DBL_EPSILON  DBL_MANT_DIG  DBL_DIG
long double            LDBL_TRUE_MIN LDBL_MIN -LDBL_MAX LDBL_MAX LDBL_EPSILON LDBL_MANT_DIG LDBL_DIG

    Specialization                                Members (continue)
std::numeric_limits<T>
      where T is       min_exponent min_exponent10  max_exponent max_exponent10    radix
float                  FLT_MIN_EXP  FLT_MIN_10_EXP  FLT_MAX_EXP  FLT_MAX_10_EXP  FLT_RADIX
double                 DBL_MIN_EXP  DBL_MIN_10_EXP  DBL_MAX_EXP  DBL_MAX_10_EXP  FLT_RADIX
long double            LDBL_MIN_EXP LDBL_MIN_10_EXP LDBL_MAX_EXP LDBL_MAX_10_EXP FLT_RADIX

.SH Example


// Run this code

 #include <limits>
 #include <iostream>

 int main()
 {
     std::cout
         << "type\\t│ lowest()\\t│ min()\\t\\t│ max()\\n"
         << "bool\\t│ "
         << std::numeric_limits<bool>::lowest() << "\\t\\t│ "
         << std::numeric_limits<bool>::min() << "\\t\\t│ "
         << std::numeric_limits<bool>::max() << '\\n'
         << "uchar\\t│ "
         << +std::numeric_limits<unsigned char>::lowest() << "\\t\\t│ "
         << +std::numeric_limits<unsigned char>::min() << "\\t\\t│ "
         << +std::numeric_limits<unsigned char>::max() << '\\n'
         << "int\\t│ "
         << std::numeric_limits<int>::lowest() << "\\t│ "
         << std::numeric_limits<int>::min() << "\\t│ "
         << std::numeric_limits<int>::max() << '\\n'
         << "float\\t│ "
         << std::numeric_limits<float>::lowest() << "\\t│ "
         << std::numeric_limits<float>::min() << "\\t│ "
         << std::numeric_limits<float>::max() << '\\n'
         << "double\\t│ "
         << std::numeric_limits<double>::lowest() << "\\t│ "
         << std::numeric_limits<double>::min() << "\\t│ "
         << std::numeric_limits<double>::max() << '\\n';
 }

.SH Possible output:

 type    │ lowest()    │ min()               │ max()
 bool    │ 0           │ 0           │ 1
 uchar   │ 0           │ 0           │ 255
 int     │ -2147483648 │ -2147483648 │ 2147483647
 float   │ -3.40282e+38        │ 1.17549e-38 │ 3.40282e+38
 double  │ -1.79769e+308       │ 2.22507e-308        │ 1.79769e+308

.SH See also

     * Fixed width integer types
     * Arithmetic types
     * C++ type system overview
     * Type support (basic types, RTTI, type traits)
