.TH std::exp(std::complex) 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::exp(std::complex) \- std::exp(std::complex)

.SH Synopsis
   Defined in header <complex>
   template< class T >
   complex<T> exp( const complex<T>& z );

   Compute base-e exponential of z, that is e (Euler's number, 2.7182818) raised to the
   z power.

.SH Parameters

   z - complex value

.SH Return value

   If no errors occur, e raised to the power of z, ez
   , is returned.

   Error handling and special values

   Errors are reported consistent with math_errhandling

   If the implementation supports IEEE floating-point arithmetic,

     * std::exp(std::conj(z)) == std::conj(std::exp(z))
     * If z is (±0,+0), the result is (1,+0)
     * If z is (x,+∞) (for any finite x), the result is (NaN,NaN) and FE_INVALID is
       raised.
     * If z is (x,NaN) (for any finite x), the result is (NaN,NaN) and FE_INVALID may
       be raised.
     * If z is (+∞,+0), the result is (+∞,+0)
     * If z is (-∞,y) (for any finite y), the result is +0cis(y)
     * If z is (+∞,y) (for any finite nonzero y), the result is +∞cis(y)
     * If z is (-∞,+∞), the result is (±0,±0) (signs are unspecified)
     * If z is (+∞,+∞), the result is (±∞,NaN) and FE_INVALID is raised (the sign of
       the real part is unspecified)
     * If z is (-∞,NaN), the result is (±0,±0) (signs are unspecified)
     * If z is (+∞,NaN), the result is (±∞,NaN) (the sign of the real part is
       unspecified)
     * If z is (NaN,+0), the result is (NaN,+0)
     * If z is (NaN,y) (for any nonzero y), the result is (NaN,NaN) and FE_INVALID may
       be raised
     * If z is (NaN,NaN), the result is (NaN,NaN)

   where cis(y) is cos(y) + i sin(y)

.SH Notes

   The complex exponential function ez
   for z = x+iy equals ex
   cis(y), or, ex
   (cos(y) + i sin(y))

   The exponential function is an entire function in the complex plane and has no
   branch cuts.

.SH Example

   
// Run this code

 #include <complex>
 #include <iostream>
  
 int main()
 {
    const double pi = std::acos(-1);
    const std::complex<double> i(0, 1);
  
    std::cout << std::fixed << " exp(i*pi) = " << std::exp(i * pi) << '\\n';
 }

.SH Output:

 exp(i*pi) = (-1.000000,0.000000)

.SH See also

                      complex natural logarithm with the branch cuts along the negative
   log(std::complex)  real axis
                      \fI(function template)\fP 
   exp                returns e raised to the given power (e^x)
                      \fI(function)\fP 
   exp(std::valarray) applies the function std::exp to each element of valarray
                      \fI(function template)\fP 
   C documentation for
   cexp
