.TH std::isinf 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::isinf \- std::isinf

.SH Synopsis
   Defined in header <cmath>
   bool isinf( float num );
                                                                \fI(since C++11)\fP
   bool isinf( double num );                                    (until C++23)

   bool isinf( long double num );
   constexpr bool isinf( /* floating-point-type */ num  \fB(1)\fP     (since C++23)
   );
   Additional overloads
   Defined in header <cmath>
   template< class Integer >                                (A) \fI(since C++11)\fP
   bool isinf( Integer num );                                   (constexpr since C++23)

   1) Determines if the given floating-point number num is a positive or negative
   infinity.
   The library provides overloads for all cv-unqualified floating-point types as the
   type of the parameter num.
   (since C++23)
   A) Additional overloads are provided for all integer types, which are treated as
   double.

.SH Parameters

   num - floating-point or integer value

.SH Return value

   true if num is infinite, false otherwise.

.SH Notes

   GCC and Clang support a -ffinite-math option (additionally implied by -ffast-math),
   which allows the respective compiler to assume the nonexistence of special IEEE-754
   floating point values such as NaN, infinity, or negative zero. In other words,
   std::isinf is assumed to always return false under this option.

   The additional overloads are not required to be provided exactly as (A). They only
   need to be sufficient to ensure that for their argument num of integer type,
   std::isinf(num) has the same effect as std::isinf(static_cast<double>(num)).

.SH Example


// Run this code

 #include <cfloat>
 #include <cmath>
 #include <iostream>
 #include <limits>

 int main()
 {
     const double max = std::numeric_limits<double>::max();
     const double inf = std::numeric_limits<double>::infinity();

     std::cout << std::boolalpha
               << "isinf(NaN) = " << std::isinf(NAN) << '\\n'
               << "isinf(Inf) = " << std::isinf(INFINITY) << '\\n'
               << "isinf(max) = " << std::isinf(max) << '\\n'
               << "isinf(inf) = " << std::isinf(inf) << '\\n'
               << "isinf(0.0) = " << std::isinf(0.0) << '\\n'
               << "isinf(exp(800)) = " << std::isinf(std::exp(800)) << '\\n'
               << "isinf(DBL_MIN/2.0) = " << std::isinf(DBL_MIN / 2.0) << '\\n';
 }

.SH Output:

 isinf(NaN) = false
 isinf(Inf) = true
 isinf(max) = false
 isinf(inf) = true
 isinf(0.0) = false
 isinf(exp(800)) = true
 isinf(DBL_MIN/2.0) = false

.SH See also

   fpclassify categorizes the given floating-point value
   \fI(C++11)\fP    \fI(function)\fP
   isfinite   checks if the given number has finite value
   \fI(C++11)\fP    \fI(function)\fP
   isnan      checks if the given number is NaN
   \fI(C++11)\fP    \fI(function)\fP
   isnormal   checks if the given number is normal
   \fI(C++11)\fP    \fI(function)\fP
   C documentation for
   isinf
