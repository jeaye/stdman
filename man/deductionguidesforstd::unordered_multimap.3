.TH deductionguidesforstd::unordered_multimap 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
deductionguidesforstd::unordered_multimap \- deductionguidesforstd::unordered_multimap

.SH Synopsis
   Defined in header <unordered_map>
   template< class InputIt,

             class Hash = std::hash<iter_key_t<InputIt>>,
             class Pred = std::equal_to<iter_key_t<InputIt>>,
             class Alloc =
   std::allocator<iter_to_alloc_t<InputIt>> >
   unordered_multimap( InputIt, InputIt,
                       typename /*see below*/::size_type =      \fB(1)\fP  \fI(since C++17)\fP
   /*see below*/,
                       Hash = Hash(), Pred = Pred(), Alloc =
   Alloc() )
       -> unordered_multimap<iter_key_t<InputIt>,
   iter_val_t<InputIt>,

                             Hash, Pred, Alloc>;
   template< class Key, class T, class Hash = std::hash<Key>,

             class Pred = std::equal_to<Key>,
             class Alloc = std::allocator<std::pair<const Key,
   T>> >
   unordered_multimap( std::initializer_list<std::pair<Key,
   T>>,                                                         \fB(2)\fP  \fI(since C++17)\fP
                       typename /*see below*/::size_type =
   /*see below*/,
                       Hash = Hash(), Pred = Pred(), Alloc =
   Alloc() )

       -> unordered_multimap<Key, T, Hash, Pred, Alloc>;
   template< class InputIt, class Alloc >

   unordered_multimap( InputIt, InputIt, typename /*see
   below*/::size_type, Alloc )
       -> unordered_multimap<iter_key_t<InputIt>,               \fB(3)\fP  \fI(since C++17)\fP
   iter_val_t<InputIt>,
                             std::hash<iter_key_t<InputIt>>,


   std::equal_to<iter_key_t<InputIt>>, Alloc>;
   template< class InputIt, class Alloc >

   unordered_multimap( InputIt, InputIt, Alloc )
       -> unordered_multimap<iter_key_t<InputIt>,
   iter_val_t<InputIt>,                                         \fB(4)\fP  \fI(since C++17)\fP
                             std::hash<iter_key_t<InputIt>>,


   std::equal_to<iter_key_t<InputIt>>, Alloc>;
   template< class InputIt, class Hash, class Alloc >

   unordered_multimap( InputIt, InputIt, typename /*see
   below*/::size_type, Hash, Alloc )
       -> unordered_multimap<iter_key_t<InputIt>,               \fB(5)\fP  \fI(since C++17)\fP
   iter_val_t<InputIt>, Hash,


   std::equal_to<iter_key_t<InputIt>>, Alloc>;
   template< class Key, class T, typename Alloc >

   unordered_multimap( std::initializer_list<std::pair<Key,
   T>>,
                       typename /*see below*/::size_type, Alloc \fB(6)\fP  \fI(since C++17)\fP
   )

       -> unordered_multimap<Key, T, std::hash<Key>,
   std::equal_to<Key>, Alloc>;
   template< class Key, class T, typename Alloc >

   unordered_multimap( std::initializer_list<std::pair<Key,
   T>>, Alloc )                                                 \fB(7)\fP  \fI(since C++17)\fP

       -> unordered_multimap<Key, T, std::hash<Key>,
   std::equal_to<Key>, Alloc>;
   template< class Key, class T, class Hash, class Alloc >

   unordered_multimap( std::initializer_list<std::pair<Key,
   T>>,
                       typename /*see below*/::size_type, Hash, \fB(8)\fP  \fI(since C++17)\fP
   Alloc )

       -> unordered_multimap<Key, T, Hash, std::equal_to<Key>,
   Alloc>;
   template< ranges::input_range R,

             class Hash = std::hash<range_key_t<R>>,
             class Pred = std::equal_to<range_key_t<R>>,
             class Alloc = std::allocator<range_to_alloc_t<R>>
   >
   unordered_multimap( std::from_range_t, R&&,                  \fB(9)\fP  (since C++23)
                       typename /* see description
   */::size_type = /* see description */,
                       Hash = Hash(), Pred = Pred(), Alloc =
   Alloc() )
       -> unordered_multimap<range_key_t<R>, range_mapped_t<R>,

                             Hash, Pred, Alloc>;
   template< ranges::input_range R, class Alloc >

   unordered_multimap( std::from_range_t, R&&,
                       typename /* see description
   */::size_type, Alloc )                                       \fB(10)\fP (since C++23)
       -> unordered_multimap<range_key_t<R>, range_mapped_t<R>,
                             std::hash<range_key_t<R>>,

                             std::equal_to<range_key_t<R>>,
   Alloc>;
   template< ranges::input_range R, class Alloc >

   unordered_multimap( std::from_range_t, R&&, Alloc )
       -> unordered_multimap<range_key_t<R>, range_mapped_t<R>, \fB(11)\fP (since C++23)
                             std::hash<range_key_t<R>>,

                             std::equal_to<range_key_t<R>>,
   Alloc>;
   template< ranges::input_range R, class Hash, class Alloc >

   unordered_multimap( std::from_range_t, R&&, typename /* see
   description */::size_type,
                       Hash, Alloc )                            \fB(12)\fP (since C++23)
       -> unordered_multimap<range_key_t<R>, range_mapped_t<R>,
   Hash,

                             std::equal_to<range_key_t<R>>,
   Alloc>;
   Exposition-only helper type aliases
   template< class InputIter >

   using iter_val_t =                                                (exposition only*)

       typename std::iterator_traits<InputIter>::value_type;
   template< class InputIter >

   using iter_key_t =                                                (exposition only*)

       std::remove_const_t< std::tuple_element_t<0,
   iter_val_t<InputIter>>>;
   template< class InputIter >

   using iter_mapped_t =                                             (exposition only*)

       std::tuple_element_t<1, iter_val_t<InputIter>>;
   template< class InputIter >

   using iter_to_alloc_t =
       std::pair<std::add_const_t<tuple_element_t<0,                 (exposition only*)
   iter_val_t<InputIter>>>,

                 std::tuple_element_t<1,
   iter_val_t<InputIter>>>;
   template< ranges::input_range Range >

   using range_key_t =                                               (since C++23)
                                                                     (exposition only*)
       std::remove_const_t<typename
   ranges::range_value_t<Range>::first_type>;
   template< ranges::input_range Range >
                                                                     (since C++23)
   using range_mapped_t =                                            (exposition only*)

       typename ranges::range_value_t<Range>::second_type;
   template< ranges::input_range Range >

   using range_to_alloc_t =
       std::pair<std::add_const_t<typename                           (since C++23)
   ranges::range_value_t<Range>::first_type>,                        (exposition only*)

                 typename
   ranges::range_value_t<Range>::second_type>;

   1-8) These deduction guide are provided for unordered_multimap to allow deduction
   from an iterator range (overloads (1,3-5)) and std::initializer_list (overloads
   (2,6-8)).
   9-12) These deduction guides are provided for unordered_multimap to allow deduction
   from a std::from_range_t tag and an input_range.

   These overloads participate in overload resolution only if InputIt satisfies
   LegacyInputIterator, Alloc satisfies Allocator, neither Hash nor Pred satisfy
   Allocator, and Hash is not an integral type.

   Note: the extent to which the library determines that a type does not satisfy
   LegacyInputIterator is unspecified, except that as a minimum integral types do not
   qualify as input iterators. Likewise, the extent to which it determines that a type
   does not satisfy Allocator is unspecified, except that as a minimum the member type
   Alloc::value_type must exist and the expression
   std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as
   an unevaluated operand.

   The size_type parameter type in these guides in an refers to the size_type member
   type of the type deduced by the deduction guide.

.SH Notes

       Feature-test macro       Value    Std                   Feature
   __cpp_lib_containers_ranges 202202L (C++23) Ranges-aware construction and insertion;
                                               overloads (9-12)

.SH Example


// Run this code

 #include <unordered_map>

 int main()
 {
     // std::unordered_multimap m1 = {{"foo", 1}, {"bar", 2}};
         // Error: braced-init-list has no type cannot
         // deduce pair<Key, T> from {"foo", 1} or {"bar", 2}

     std::unordered_multimap m1 = {std::pair{"foo", 2}, {"bar", 3}}; // guide #2
     std::unordered_multimap m2(m1.begin(), m1.end()); // guide #1
 }

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to           Behavior as published              Correct behavior
   LWG 3025 C++17      initializer-list guides take               use std::pair<Key, T>
                       std::pair<const Key, T>
