.TH std::tanh(std::complex) 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::tanh(std::complex) \- std::tanh(std::complex)

.SH Synopsis
   Defined in header <complex>
   template< class T >                      \fI(since C++11)\fP
   complex<T> tanh( const complex<T>& z );

   Computes complex hyperbolic tangent of a complex value z.

.SH Parameters

   z - complex value

.SH Return value

   If no errors occur, complex hyperbolic tangent of z is returned.

   Error handling and special values

   Errors are reported consistent with math_errhandling.

   If the implementation supports IEEE floating-point arithmetic,

     * std::tanh(std::conj(z)) == std::conj(std::tanh(z)).
     * std::tanh(-z) == -std::tanh(z).
     * If z is (+0,+0), the result is (+0,+0).
     * If z is (x,+∞) (for any^[1] finite x), the result is (NaN,NaN) and FE_INVALID is
       raised.
     * If z is (x,NaN) (for any^[2] finite x), the result is (NaN,NaN) and FE_INVALID
       may be raised.
     * If z is (+∞,y) (for any finite positive y), the result is (1,+0).
     * If z is (+∞,+∞), the result is (1,±0) (the sign of the imaginary part is
       unspecified).
     * If z is (+∞,NaN), the result is (1,±0) (the sign of the imaginary part is
       unspecified).
     * If z is (NaN,+0), the result is (NaN,+0).
     * If z is (NaN,y) (for any non-zero y), the result is (NaN,NaN) and FE_INVALID may
       be raised.
     * If z is (NaN,NaN), the result is (NaN,NaN).
    1. ↑ per C11 DR471, this only holds for non-zero x. If z is (0,∞), the result
       should be (0,NaN).
    2. ↑ per C11 DR471, this only holds for non-zero x. If z is (0,NaN), the result
       should be (0,NaN).

.SH Notes

   Mathematical definition of hyperbolic tangent is tanh z =

   ez
   -e-z
   ez
   +e-z

   .

   Hyperbolic tangent is an analytical function on the complex plane and has no branch
   cuts. It is periodic with respect to the imaginary component, with period πi, and
   has poles of the first order along the imaginary line, at coordinates (0, π(1/2 +
   n)). However no common floating-point representation is able to represent π/2
   exactly, thus there is no value of the argument for which a pole error occurs.

.SH Example


// Run this code

 #include <cmath>
 #include <complex>
 #include <iostream>

 int main()
 {
     std::cout << std::fixed;
     std::complex<double> z(1.0, 0.0); // behaves like real tanh along the real line
     std::cout << "tanh" << z << " = " << std::tanh(z)
               << " (tanh(1) = " << std::tanh(1) << ")\\n";

     std::complex<double> z2(0.0, 1.0); // behaves like tangent along the imaginary line
     std::cout << "tanh" << z2 << " = " << std::tanh(z2)
               << " ( tan(1) = " << std::tan(1) << ")\\n";
 }

.SH Output:

 tanh(1.000000,0.000000) = (0.761594,0.000000) (tanh\fB(1)\fP = 0.761594)
 tanh(0.000000,1.000000) = (0.000000,1.557408) ( tan\fB(1)\fP = 1.557408)

.SH See also

                       computes hyperbolic sine of a complex number
   sinh(std::complex)  (\\({\\small\\sinh{z}}\\)sinh(z))
                       \fI(function template)\fP
                       computes hyperbolic cosine of a complex number
   cosh(std::complex)  (\\({\\small\\cosh{z}}\\)cosh(z))
                       \fI(function template)\fP
   atanh(std::complex) computes area hyperbolic tangent of a complex number
   \fI(C++11)\fP             (\\({\\small\\operatorname{artanh}{z}}\\)artanh(z))
                       \fI(function template)\fP
   tanh
   tanhf               computes hyperbolic tangent (\\({\\small\\tanh{x}}\\)tanh(x))
   tanhl               \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   tanh(std::valarray) applies the function std::tanh to each element of valarray
                       \fI(function template)\fP
   C documentation for
   ctanh
