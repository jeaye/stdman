.TH std::rotr 3 "2022.03.29" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::rotr \- std::rotr

.SH Synopsis
   Defined in header <bit>
   template< class T >                                     \fI(since C++20)\fP
   [[nodiscard]] constexpr T rotr( T x, int s ) noexcept;

   Computes the result of bitwise right-rotating the value of x by s positions. This
   operation is also known as a right circular shift.

   Formally, let N be std::numeric_limits<T>::digits, r be s % N.

     * If r is 0, returns x;
     * if r is positive, returns (x >> r) | (x << (N - r));
     * if r is negative, returns std::rotl(x, -r).

   This overload participates in overload resolution only if T is an unsigned integer
   type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned
   long long, or an extended unsigned integer type).

.SH Parameters

   x - values of unsigned integer type

.SH Return value

   The result of bitwise right-rotating x by s positions.

.SH Notes

   Feature testing macro: __cpp_lib_bitops

.SH Example


// Run this code

 #include <bit>
 #include <bitset>
 #include <cstdint>
 #include <iostream>

 int main()
 {
     const std::uint8_t i = 0b00011101;
     std::cout << "i          = " << std::bitset<8>(i) << '\\n';
     std::cout << "rotr(i,0)  = " << std::bitset<8>(std::rotr(i,0)) << '\\n';
     std::cout << "rotr(i,1)  = " << std::bitset<8>(std::rotr(i,1)) << '\\n';
     std::cout << "rotr(i,9)  = " << std::bitset<8>(std::rotr(i,9)) << '\\n';
     std::cout << "rotr(i,-1) = " << std::bitset<8>(std::rotr(i,-1)) << '\\n';
 }

.SH Output:

 i          = 00011101
 rotr(i,0)  = 00011101
 rotr(i,1)  = 10001110
 rotr(i,9)  = 10001110
 rotr(i,-1) = 00111010

.SH See also

   rotl        computes the result of bitwise left-rotation
   (C++20)     \fI(function template)\fP
   operator<<=
   operator>>= performs binary shift left and shift right
   operator<<  \fI(public member function of std::bitset<N>)\fP
   operator>>
