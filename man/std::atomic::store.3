.TH std::atomic::store 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic::store \- std::atomic::store

.SH Synopsis
   void store( T desired, std::memory_order order =                   \fB(1)\fP \fI(since C++11)\fP
                              std::memory_order_seq_cst ) noexcept;
   void store( T desired, std::memory_order order =
                              std::memory_order_seq_cst ) volatile    \fB(2)\fP \fI(since C++11)\fP
   noexcept;

   Atomically replaces the current value with desired. Memory is affected according to
   the value of order.

   If order is one of std::memory_order_consume, std::memory_order_acquire and
   std::memory_order_acq_rel, the behavior is undefined.

   It is deprecated if std::atomic<T>::is_always_lock_free is false and   \fI(since C++20)\fP
   overload \fB(2)\fP participates in overload resolution.

.SH Parameters

   desired - the value to store into the atomic variable
   order   - memory order constraints to enforce

.SH Return value

   \fI(none)\fP

.SH See also

   operator=             stores a value into an atomic object
                         \fI(public member function)\fP
   atomic_store          atomically replaces the value of the atomic object with a
   atomic_store_explicit non-atomic argument
   \fI(C++11)\fP               \fI(function template)\fP
   \fI(C++11)\fP
