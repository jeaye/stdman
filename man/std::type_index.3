.TH std::type_index 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::type_index \- std::type_index

.SH Synopsis
   Defined in header <typeindex>
   class type_index;              \fI(since C++11)\fP

   The type_index class is a wrapper class around a std::type_info object, that can be
   used as index in associative and unordered associative containers. The relationship
   with type_info object is maintained through a pointer, therefore type_index is
   CopyConstructible and CopyAssignable.

.SH Member functions

   constructor           constructs the object
                         \fI(public member function)\fP 
   destructor            destroys the type_index object
   (implicitly declared) \fI(public member function)\fP
   operator=             assigns a type_index object
   (implicitly declared) \fI(public member function)\fP
   operator==
   operator!=
   operator<             compares the underlying std::type_info objects
   operator<=            \fI(public member function)\fP 
   operator>
   operator>=
   hash_code             returns hashed code
                         \fI(public member function)\fP 
                         returns implementation defined name of the type,
   name                  associated with underlying type_info object
                         \fI(public member function)\fP 

.SH Helper classes

   std::hash<std::type_index> hash support for std::type_index
   \fI(C++11)\fP                    \fI(class template specialization)\fP 

.SH Example

   The following program is an example of an efficient type-value mapping.

   
// Run this code

 #include <iostream>
 #include <typeinfo>
 #include <typeindex>
 #include <unordered_map>
 #include <string>
 #include <memory>
  
 struct A {
     virtual ~A() {}
 };
  
 struct B : A {};
 struct C : A {};
  
 int main()
 {
     std::unordered_map<std::type_index, std::string> type_names;
  
     type_names[std::type_index(typeid(int))] = "int";
     type_names[std::type_index(typeid(double))] = "double";
     type_names[std::type_index(typeid(A))] = "A";
     type_names[std::type_index(typeid(B))] = "B";
     type_names[std::type_index(typeid(C))] = "C";
  
     int i;
     double d;
     A a;
  
     // note that we're storing pointer to type A
     std::unique_ptr<A> b(new B);
     std::unique_ptr<A> c(new C);
  
     std::cout << "i is " << type_names[std::type_index(typeid(i))] << '\\n';
     std::cout << "d is " << type_names[std::type_index(typeid(d))] << '\\n';
     std::cout << "a is " << type_names[std::type_index(typeid(a))] << '\\n';
     std::cout << "b is " << type_names[std::type_index(typeid(*b))] << '\\n';
     std::cout << "c is " << type_names[std::type_index(typeid(*c))] << '\\n';
 }

.SH Output:

 i is int
 d is double
 a is A
 b is B
 c is C

.SH See also

             contains some type's information, generated by the implementation.
   type_info This is the class returned by the typeid operator.
             \fI(class)\fP 
