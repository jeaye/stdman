.TH std::literals::complex_literals::operator""i,operator""if,operator""il 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::literals::complex_literals::operator""i,operator""if,operator""il \- std::literals::complex_literals::operator""i,operator""if,operator""il

.SH Synopsis
   Defined in header <complex>
   constexpr complex<double> operator""i(long double arg);            \fB(1)\fP \fI(since C++14)\fP
   constexpr complex<double> operator""i(unsigned long long arg);
   constexpr complex<float> operator""if(long double arg);            \fB(2)\fP \fI(since C++14)\fP
   constexpr complex<float> operator""if(unsigned long long arg);
   constexpr complex<long double> operator""il(long double arg);
   constexpr complex<long double> operator""il(unsigned long long     \fB(3)\fP \fI(since C++14)\fP
   arg);

   Forms a std::complex literal representing an imaginary number.

   1) forms a literal std::complex<double> with the real part zero and imaginary part
   arg
   2) forms a literal std::complex<float> with the real part zero and imaginary part
   arg
   3) forms a literal std::complex<long double> with the real part zero and imaginary
   part arg

.SH Parameters

   arg - the value of the imaginary number

.SH Return value

   The std::complex literal with the real part zero and imaginary part arg

.SH Notes

   These operators are declared in the namespace std::literals::complex_literals, where
   both literals and complex_literals are inline namespaces. Access to these operators
   can be gained with using namespace std::literals, using namespace
   std::complex_literals, and using namespace std::literals::complex_literals.

   Even though if is a keyword in C++, it is a ud-suffix of the literal operator of the
   form operator ""if and in the literal expressions such as 1if or 1.0if because it is
   not separated by whitespace and is not a standalone token.

.SH Possible implementation

.SH First version
   constexpr std::complex<double> operator""i(unsigned long long d)
   {
       return std::complex<double>{0.0, static_cast<double>(d)};
   }
   constexpr std::complex<double> operator""i(long double d)
   {
       return std::complex<double>{0.0, static_cast<double>(d)};
   }
.SH Second version
   constexpr std::complex<float> operator""if(unsigned long long d)
   {
       return std::complex<float>{0.0f, static_cast<float>(d)};
   }
   constexpr std::complex<float> operator""if(long double d)
   {
       return std::complex<float>{0.0f, static_cast<float>(d)};
   }
                                Third version
   constexpr std::complex<long double> operator""il(unsigned long long d)
   {
       return std::complex<long double>{0.0L, static_cast<long double>(d)};
   }
   constexpr std::complex<long double> operator""il(long double d)
   {
       return std::complex<long double>{0.0L, d};
   }

.SH Example

   
// Run this code

 #include <iostream>
 #include <complex>
  
 int main()
 {
     using namespace std::complex_literals;
     std::complex<double> c = 1.0 + 1i;
     std::cout << "abs" << c << " = " << abs(c) << '\\n';
 }

.SH Output:

 abs(1,1) = 1.41421

.SH See also

   constructor   constructs a complex number
                 \fI(public member function)\fP 
   operator=     assigns the contents
                 \fI(public member function)\fP 
   C documentation for
   I
