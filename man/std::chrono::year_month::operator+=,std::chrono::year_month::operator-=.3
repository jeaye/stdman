.TH std::chrono::year_month::operator+=,std::chrono::year_month::operator-= 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::chrono::year_month::operator+=,std::chrono::year_month::operator-= \- std::chrono::year_month::operator+=,std::chrono::year_month::operator-=

.SH Synopsis
   constexpr std::chrono::year_month& operator+=(const                \fB(1)\fP \fI(since C++20)\fP
   std::chrono::years& dy) const noexcept;
   constexpr std::chrono::year_month& operator+=(const                \fB(2)\fP \fI(since C++20)\fP
   std::chrono::months& dm) const noexcept;
   constexpr std::chrono::year_month& operator-=(const                \fB(3)\fP \fI(since C++20)\fP
   std::chrono::years& dy) const noexcept;
   constexpr std::chrono::year_month& operator-=(const                \fB(4)\fP \fI(since C++20)\fP
   std::chrono::months& dm) const noexcept;

   Modifies the time point *this represents by the duration dy or dm.

   1) Equivalent to *this = *this + dy;
   2) Equivalent to *this = *this + dm;
   3) Equivalent to *this = *this - dy;
   4) Equivalent to *this = *this - dm;

   For durations that are convertible to both std::chrono::years and
   std::chrono::months, the years overloads (1,3) are preferred if the call would
   otherwise be ambiguous.

.SH See also

   operator+ performs arithmetic on year_month
   operator- \fI(function)\fP

.SH Example


// Run this code

 #include <iostream>
 #include <chrono>

 int main()
 {
     std::cout << std::boolalpha;

     auto ym {std::chrono::day(1)/7/2023};

     ym -= std::chrono::years {2};
     std::cout << (ym.month() == std::chrono::July) << ' '
               << (ym.year() == std::chrono::year(2021)) << ' ';

     ym += std::chrono::months {7};
     std::cout << (ym.month() == std::chrono::month(2)) << ' '
               << (ym.year() == std::chrono::year(2022)) << '\\n';
 }

.SH Output:

 true true true true
