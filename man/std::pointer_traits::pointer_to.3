.TH std::pointer_traits::pointer_to 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pointer_traits::pointer_to \- std::pointer_traits::pointer_to

.SH Synopsis
   Defined in header <memory>
                                                         \fI(since C++11)\fP
   static pointer pointer_to( element_type& r );     \fB(1)\fP (member of pointer_traits<Ptr>
                                                         specialization)
   static pointer pointer_to( element_type& r )          \fI(since C++11)\fP
   noexcept;                                         \fB(2)\fP (member of pointer_traits<T*>
                                                         specialization)

   Constructs a dereferenceable pointer or pointer-like object ("fancy pointer") to its
   argument.

   1) The version of this function in the non-specialized std::pointer_traits template
   simply calls Ptr::pointer_to(r), and if Ptr does not provide a static member
   function pointer_to, instantiation of this function is a compile-time error.
   2) The version of this function in the specialization of std::pointer_traits for
   pointer types returns std::addressof(r)

.SH Parameters

   r - reference to an object of type element_type&, except if element_type is void, in
       which case the type of r is unspecified

.SH Return value

   A dereferenceable pointer to r, of the type pointer_traits<>::pointer.

.SH Exceptions

   1) Unspecified (typically same as Ptr::pointer_to)

.SH Notes

   The Boost.Intrusive library version of this function returns
   pointer(std::addressof(r)) if Ptr::pointer_to does not exist.

.SH See also

   addressof             obtains actual address of an object, even if the & operator is
   \fI(C++11)\fP               overloaded
                         \fI(function template)\fP 
   address               obtains the address of an object, even if operator& is
   (deprecated in C++17) overloaded
                         \fI(public member function of std::allocator)\fP 
   to_address            obtains a raw pointer from a fancy pointer (inverse of
   \fB[static]\fP (C++20)      pointer_to)
                         \fI(public static member function)\fP 
   to_address            obtains a raw pointer from a pointer-like type
   (C++20)               \fI(function template)\fP 
