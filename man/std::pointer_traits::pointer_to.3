.TH std::pointer_traits::pointer_to 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pointer_traits::pointer_to \- std::pointer_traits::pointer_to

.SH Synopsis
   Defined in header <memory>
   static pointer pointer_to(               \fI(since C++11)\fP
   element_type& r );                   \fB(1)\fP (member of pointer_traits<Ptr>
                                            specialization)
   static pointer pointer_to(               \fI(since C++11)\fP
   element_type& r );                   \fB(2)\fP (member of pointer_traits<T*>
                                            specialization)

   Constructs a dereferenceable pointer to its argument.

   1) The version of this function in the non-specialized std::pointer_traits template
   simply calls Ptr::pointer_to(r), and if Ptr does not provide a static member
   function pointer_to, instantiation of this function is a compile-time error.
   2) The version of this function in the specialization of std::pointer_traits for
   pointer types returns std::addressof(r)

.SH Parameters

   r - reference to an object of type element_type&, except if element_type is void, in
       which case the type of r is unspecified

.SH Return value

   A dereferenceable pointer to r, of the type pointer_traits<>::pointer.

.SH Exceptions

   1) Unspecified (typically same as Ptr::pointer_to)
   2)
   noexcept specification:  
   noexcept
     

.SH Notes

   The boost library version of this function returns pointer(std::addressof(r)) if
   Ptr::pointer_to does not exist.

.SH See also

   addressof obtains actual address of an object, even if the & operator is overloaded
   \fI(C++11)\fP   \fI(function template)\fP 
   address   obtains the address of an object, even if operator& is overloaded
             \fI(public member function of std::allocator)\fP 

.SH Category:

     * unconditionally noexcept
