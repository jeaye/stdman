.TH std::pointer_traits::pointer_to 3 "2022.03.29" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pointer_traits::pointer_to \- std::pointer_traits::pointer_to

.SH Synopsis
   Defined in header
   <memory>
   static pointer         \fI(since C++11)\fP
   pointer_to(        \fB(1)\fP (member of pointer_traits<Ptr>
   element_type& r );     specialization)
   static pointer                                                    \fI(since C++11)\fP
   pointer_to(                                                       \fI(until C++20)\fP
   element_type& r )                                                 (member of
   noexcept;                                                         pointer_traits<T*>
                      \fB(2)\fP                                            specialization)
   static constexpr                                                  \fI(since C++20)\fP
   pointer                                                           (member of
   pointer_to(                                                       pointer_traits<T*>
   element_type& r )                                                 specialization)
   noexcept;

   Constructs a dereferenceable pointer or pointer-like object ("fancy pointer") to its
   argument.

   1) The version of this function in the non-specialized std::pointer_traits template
   simply calls Ptr::pointer_to(r), and if Ptr does not provide a static member
   function pointer_to, instantiation of this function is a compile-time error.
   2) The version of this function in the specialization of std::pointer_traits for
   pointer types returns std::addressof(r)

.SH Parameters

   r - reference to an object of type element_type&, except if element_type is void, in
       which case the type of r is unspecified

.SH Return value

   A dereferenceable pointer to r, of the type pointer_traits<>::pointer.

.SH Exceptions

   1) Unspecified (typically same as Ptr::pointer_to)

.SH Notes

   The Boost.Intrusive library version of this function returns
   pointer(std::addressof(r)) if Ptr::pointer_to does not exist.

.SH See also

   addressof                  obtains actual address of an object, even if the &
   \fI(C++11)\fP                    operator is overloaded
                              \fI(function template)\fP
   address                    obtains the address of an object, even if operator& is
   (deprecated in C++17)      overloaded
   (removed in C++20)         \fI(public member function of std::allocator<T>)\fP
   to_address                 obtains a raw pointer from a fancy pointer (inverse of
   \fB[static]\fP (C++20)(optional) pointer_to)
                              \fI(public static member function)\fP
   to_address                 obtains a raw pointer from a pointer-like type
   (C++20)                    \fI(function template)\fP
