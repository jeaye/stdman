.TH std::initializer_list::initializer_list 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::initializer_list::initializer_list \- std::initializer_list::initializer_list

.SH Synopsis
   initializer_list() noexcept;            \fI(since C++11)\fP
                                           \fI(until C++14)\fP
   constexpr initializer_list() noexcept;  \fI(since C++14)\fP

   Constructs an empty initializer list.

.SH Parameters

   \fI(none)\fP

.SH Complexity

   Constant

.SH Example

   
// Run this code

 #include <iostream>
 #include <initializer_list>
  
 int main()
 {
     std::initializer_list<int> empty_list;
     std::cout << "empty_list.size(): " << empty_list.size() << '\\n';
  
     // create initializer lists using list-initialization
     std::initializer_list<int> digits {1, 2, 3, 4, 5};
     std::cout << "digits.size(): " << digits.size() << '\\n';
  
     // special rule for auto means 'fractions' has the
     // type std::initializer_list<double>
     auto fractions = {3.14159, 2.71828};
     std::cout << "fractions.size(): " << fractions.size() << '\\n';
 }

.SH Output:

 empty_list.size(): 0
 digits.size(): 5
 fractions.size(): 2

.SH Notes

   Despite a lack of constructors, it is possible to create non-empty initializer
   lists. Instances of std::initializer_list are implicitly constructed when:

     * a braced-init-list is used in list-initialization, including function-call list
       initialization and assignment expressions (not to be confused with constructor
       initializer lists)
     * a braced-init-list is bound to auto, including in a ranged for loop
