.TH std::initializer_list::initializer_list 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   initializer_list();            \fI(since C++11)\fP
                                  \fI(until C++14)\fP
   constexpr initializer_list();  \fI(since C++14)\fP

   Constructs an empty initializer list.

.SH Contents

     • 1 Parameters
     • 2 Exceptions
     • 3 Complexity
     • 4 Example
     • 5 Notes

.SH Parameters

   \fI(none)\fP

.SH Exceptions

   noexcept specification:  
   noexcept
     

.SH Complexity

   Constant

.SH Example

   
// Run this code

 #include <iostream>
 #include <initializer_list>
  
 int main()
 {
     std::initializer_list<int> empty_list;
     std::cout << "empty_list.size(): " << empty_list.size() << '\\n';
  
     // create initializer lists using list-initialization
     std::initializer_list<int> digits {1, 2, 3, 4, 5};
     std::cout << "digits.size(): " << digits.size() << '\\n';
  
     // special rule for auto means 'fractions' has the
     // type std::initializer_list<double>
     auto fractions = {3.14159, 2.71828};
     std::cout << "fractions.size(): " << fractions.size() << '\\n';
 }

.SH Output:

 empty_list.size(): 0
 digits.size(): 5
 fractions.size(): 2

.SH Notes

   Despite a lack of constructors, it is possible to create non-empty initializer
   lists. Instances of std::initializer_list are implicitly constructed when:

     • a braced-init-list is used in list-initialization, including function-call list
       initialization and assignment expressions (not to be confused with constructor
       initializer lists)
     • a braced-init-list is bound to auto, including in a ranged for loop
