.TH deductionguidesforstd::flat_map 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
deductionguidesforstd::flat_map \- deductionguidesforstd::flat_map

.SH Synopsis
   Defined in header <flat_map>
   template< class KeyContainer, class MappedContainer,

             class Compare = std::less<typename
   KeyContainer::value_type> >
   flat_map( KeyContainer, MappedContainer, Compare = Compare() )    \fB(1)\fP  (since C++23)
       -> flat_map<typename KeyContainer::value_type,
                   typename MappedContainer::value_type,

                   Compare, KeyContainer, MappedContainer>;
   template< class KeyContainer, class MappedContainer, class
   Allocator >

   flat_map( KeyContainer, MappedContainer, Allocator )
       -> flat_map<typename KeyContainer::value_type,                \fB(2)\fP  (since C++23)
                   typename MappedContainer::value_type,
                   std::less<typename KeyContainer::value_type>,

                   KeyContainer, MappedContainer>;
   template< class KeyContainer, class MappedContainer,

             class Compare, class Allocator >
   flat_map( KeyContainer, MappedContainer, Compare, Allocator )     \fB(3)\fP  (since C++23)
       -> flat_map<typename KeyContainer::value_type,
                   typename MappedContainer::value_type,

                   Compare, KeyContainer, MappedContainer>;
   template< class KeyContainer, class MappedContainer,

             class Compare = std::less<typename
   KeyContainer::value_type> >
   flat_map( std::sorted_unique_t, KeyContainer, MappedContainer,    \fB(4)\fP  (since C++23)
             Compare = Compare() )
       -> flat_map<typename KeyContainer::value_type,
                   typename MappedContainer::value_type,

                   Compare, KeyContainer, MappedContainer>;
   template< class KeyContainer, class MappedContainer, class
   Allocator >

   flat_map( std::sorted_unique_t, KeyContainer, MappedContainer,
             Allocator )                                             \fB(5)\fP  (since C++23)
       -> flat_map<typename KeyContainer::value_type,
                   typename MappedContainer::value_type,
                   std::less<typename KeyContainer::value_type>,

                   KeyContainer, MappedContainer>;
   template< class KeyContainer, class MappedContainer,

             class Compare, class Allocator>
   flat_map( std::sorted_unique_t, KeyContainer, MappedContainer,
             Compare, Allocator )                                    \fB(6)\fP  (since C++23)
       -> flat_map<typename KeyContainer::value_type,
                   typename MappedContainer::value_type,

                   Compare, KeyContainer, MappedContainer>;
   template< class InputIter,

             class Compare = std::less</*iter-key-type*/<InputIter>>
   >                                                                 \fB(7)\fP  (since C++23)
   flat_map( InputIter, InputIter, Compare = Compare() )
       -> flat_map</*iter-key-type*/<InputIter>,

                   /*iter-mapped-type*/<InputIter>, Compare>;
   template< class InputIter,

             class Compare = std::less</*iter-key-type*/<InputIter>>
   >
   flat_map( std::sorted_unique_t, InputIter, InputIter,             \fB(8)\fP  (since C++23)
             Compare = Compare() )
       -> flat_map</*iter-key-type*/<InputIter>,

                   /*iter-mapped-type*/<InputIter>, Compare>;
   template< ranges::input_range R,

             class Compare = std::less</*range-key-type*/<R>>,
             class Allocator = allocator<byte> >
   flat_map( std::from_range_t, R&&, Compare = Compare(),
             Allocator = Allocator() )
       -> flat_map</*range-key-type*/<R>, /*range-mapped-type*/<R>,
   Compare,
                   std::vector</*range-key-type*/<R>,                \fB(9)\fP  (since C++23)
                               /*alloc-rebind*/<Allocator,

    /*range-key-type*/<R>>>,
                   std::vector</*range-mapped-type*/<R>,
                               /*alloc-rebind*/<Allocator,


    /*range-mapped-type*/<R>>>>;
   template< ranges::input_range R, class Allocator >

   flat_map( std::from_range_t, R&&, Allocator )
       -> flat_map</*range-key-type*/<R>, /*range-mapped-type*/<R>,
                   std::less</*range-key-type*/<R>>,
                   std::vector</*range-key-type*/<R>,
                               /*alloc-rebind*/<Allocator,           \fB(10)\fP (since C++23)

    /*range-key-type*/<R>>>,
                   std::vector</*range-mapped-type*/<R>,
                               /*alloc-rebind*/<Allocator,


    /*range-mapped-type*/<R>>>>;
   template< class Key, class T, class Compare = std::less<Key> >

   flat_map( std::initializer_list<pair<Key, T>>, Compare =          \fB(11)\fP (since C++23)
   Compare() )

       -> flat_map<Key, T, Compare>;
   template< class Key, class T, class Compare = std::less<Key> >

   flat_map( std::sorted_unique_t, std::initializer_list<pair<Key,
   T>>,                                                              \fB(12)\fP (since C++23)
             Compare = Compare() )

       -> flat_map<Key, T, Compare>;

   These deduction guides are provided for to allow deduction from:

   1) A key-container, a mapped-container and a comparator.
   2) A key-container, a mapped-container and an allocator.
   3) A key-container, a mapped-container, a comparator and an allocator.
   4) The std::sorted_unique_t tag, a key-container, a mapped-container and a
   comparator.
   5) The std::sorted_unique_t tag, a key-container, a mapped-container and an
   allocator.
   6) The std::sorted_unique_t tag, a key-container, a mapped-container, a comparator
   and an allocator.
   7) An iterator range and a comparator.
   8) The std::sorted_unique_t tag, an iterator range and a comparator.
   9) The std::from_range_t tag, an input_range range, a comparator and an allocator.
   10) The std::from_range_t tag, an input_range range and an allocator.
   11) The std::initializer_list and a comparator.
   12) The std::sorted_unique_t tag, the std::initializer_list and a comparator.

   These overloads participate in overload resolution only if InputIt satisfies
   LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.

   Note: the extent to which the library determines that a type does not satisfy
   LegacyInputIterator is unspecified, except that as a minimum integral types do not
   qualify as input iterators. Likewise, the extent to which it determines that a type
   does not satisfy Allocator is unspecified, except that as a minimum the member type
   Alloc::value_type must exist and the expression
   std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as
   an unevaluated operand.

.SH Example

    This section is incomplete
    Reason: no example

.SH Category:
     * Todo no example
