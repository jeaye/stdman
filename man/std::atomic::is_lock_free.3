.TH std::atomic::is_lock_free 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic::is_lock_free \- std::atomic::is_lock_free

.SH Synopsis
   bool is_lock_free() const noexcept;           \fI(since C++11)\fP
   bool is_lock_free() const volatile noexcept;

   Checks whether the atomic operations on all objects of this type are lock-free.

.SH Parameters

   \fI(none)\fP

.SH Return value

   true if the atomic operations on the objects of this type are lock-free, false
   otherwise.

.SH Notes

   All atomic types except for std::atomic_flag may be implemented using mutexes or
   other locking operations, rather than using the lock-free atomic CPU instructions.
   Atomic types are also allowed to be sometimes lock-free, e.g. if only aligned memory
   accesses are naturally atomic on a given architecture, misaligned objects of the
   same type have to use locks.

   The C++ standard recommends (but does not require) that lock-free atomic operations
   are also address-free, that is, suitable for communication between processes using
   shared memory.

.SH Example

   
// Run this code

 #include <iostream>
 #include <utility>
 #include <atomic>
  
 struct A { int a[100]; };
 struct B { int x, y; };
 int main()
 {
     std::cout << std::boolalpha
               << "std::atomic<A> is lock free? "
               << std::atomic<A>{}.is_lock_free() << '\\n'
               << "std::atomic<B> is lock free? "
               << std::atomic<B>{}.is_lock_free() << '\\n';
 }

.SH Possible output:

 std::atomic<A> is lock free? false
 std::atomic<B> is lock free? true

.SH See also

   atomic_is_lock_free checks if the atomic type's operations are lock-free
   \fI(C++11)\fP             \fI(function template)\fP 
   is_always_lock_free indicates that the type is always lock-free
   \fB[static]\fP \fI(C++17)\fP    \fI(public static member constant)\fP 

.SH Category:

     * Uses of dcl rev begin with nonempty note
