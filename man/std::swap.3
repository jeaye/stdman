.TH std::swap 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::swap \- std::swap

.SH Synopsis
   Defined in header <algorithm>                            \fI(until C++11)\fP
   Defined in header <utility>                              \fI(since C++11)\fP
   template< class T >                                                    \fI(until C++11)\fP
   void swap( T& a, T& b );
   template< class T >                                                    \fI(since C++11)\fP
   void swap( T& a, T& b ) noexcept(/* see below */);   \fB(1)\fP
   template< class T2, std::size_t N >
   void swap( T2 (&a)[N], T2 (&b)[N]) noexcept(/* see       \fB(2)\fP           \fI(since C++11)\fP
   below */);

   Exchanges the given values.

   1) Swaps the values a and b.
   This overload does not participate in overload resolution unless
   std::is_move_constructible_v<T> && std::is_move_assignable_v<T> is true.
   \fI(since C++17)\fP
   2) Swaps the arrays a and b. In effect calls std::swap_ranges(a, a+N, b).
   This overload does not participate in overload resolution unless
   std::is_swappable_v<T2> is true.
   \fI(since C++17)\fP

.SH Parameters

   a, b              -              the values to be swapped
.SH Type requirements
   -
   T must meet the requirements of MoveAssignable and MoveConstructible.
   -
   T2 must meet the requirements of Swappable.

.SH Return value

   \fI(none)\fP

.SH Exceptions

   1)

   \fI(none)\fP                                              \fI(until C++11)\fP
   noexcept specification:  
   noexcept(

       std::is_nothrow_move_constructible<T>::value && \fI(since C++11)\fP
       std::is_nothrow_move_assignable<T>::value

   )

   2)

   noexcept specification:  
   noexcept(noexcept(swap(*a, *b)))
   The lookup for the identifier swap in the exception specification      \fI(until C++17)\fP
   finds this function template in addition to anything found by the
   usual lookup rules, making the exception specification equivalent to
   C++17 std::is_nothrow_swappable.
   noexcept specification:                                                \fI(since C++17)\fP
   noexcept(std::is_nothrow_swappable_v<T2>)

.SH Complexity

   1) Constant
   2) Linear in N

.SH Specializations

   std::swap may be specialized in namespace std for user-defined types, but such
   specializations are not found by ADL (the namespace std is not the associated
   namespace for the user-defined type). The expected way to make a user-defined type
   swappable is to provide a non-member function swap in the same namespace as the
   type: see Swappable for details.

   The following overloads are already provided by the standard library:

   std::swap(std::pair)                specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::tuple)               specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::shared_ptr)          specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::weak_ptr)            specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::unique_ptr)          specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::function)            specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_string)        specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::array)               specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::deque)               specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::forward_list)        specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::list)                specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::vector)              specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::map)                 specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::multimap)            specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::set)                 specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::multiset)            specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::unordered_map)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::unordered_multimap)  specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::unordered_set)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::unordered_multiset)  specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::queue)               specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::priority_queue)      specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::stack)               specializes the std::swap algorithm
                                       \fI(function template)\fP 
   std::swap(std::valarray)            specializes the std::swap() algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_stringbuf)     specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_istringstream) specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_ostringstream) specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_stringstream)  specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_filebuf)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_ifstream)      specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_ofstream)      specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_fstream)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::basic_syncbuf)       specializes the std::swap algorithm
   (C++20)                             \fI(function template)\fP 
   std::swap(std::basic_regex)         specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::match_results)       specializes the std::swap() algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::thread)              specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::unique_lock)         specialization of std::swap for unique_lock
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::promise)             specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::packaged_task)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP 
   std::swap(std::optional)            specializes the std::swap algorithm
   \fI(C++17)\fP                             \fI(function)\fP 
   std::swap(std::any)                 specializes the std::swap algorithm
   \fI(C++17)\fP                             \fI(function)\fP 
   std::swap(std::variant)             specializes the std::swap algorithm
   \fI(C++17)\fP                             \fI(function)\fP 
   swap(std::filesystem::path)         swaps two paths
                                       \fI(function)\fP 

.SH Example

   
// Run this code

 #include <algorithm>
 #include <iostream>
  
 int main()
 {
    int a = 5, b = 3;
  
    // before
    std::cout << a << ' ' << b << '\\n';
  
    std::swap(a,b);
  
    // after
    std::cout << a << ' ' << b << '\\n';
 }

.SH Output:

 5 3
 3 5

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to              Behavior as published              Correct behavior
   LWG 2554 C++11      swapping multi-dimensional arrays can never be  made to work
                       noexcept due to name lookup problems

.SH See also

   iter_swap   swaps the elements pointed to by two iterators
               \fI(function template)\fP 
   swap_ranges swaps two ranges of elements
               \fI(function template)\fP 

.SH Category:

     * conditionally noexcept
