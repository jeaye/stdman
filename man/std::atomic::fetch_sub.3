.TH std::atomic::fetch_sub 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic::fetch_sub \- std::atomic::fetch_sub

.SH Synopsis
   member only of atomic<Integral > specializations
   and atomic<Floating > specializations
   \fI(since C++20)\fP
   T fetch_sub( T arg, std::memory_order order =                      \fB(1)\fP \fI(since C++11)\fP
                           std::memory_order_seq_cst ) noexcept;
   T fetch_sub( T arg, std::memory_order order =
                           std::memory_order_seq_cst ) volatile       \fB(2)\fP \fI(since C++11)\fP
   noexcept;
   member only of atomic<T*> partial specialization
   T* fetch_sub( std::ptrdiff_t arg,

                 std::memory_order order =                            \fB(3)\fP \fI(since C++11)\fP

                     std::memory_order_seq_cst ) noexcept;
   T* fetch_sub( std::ptrdiff_t arg,

                 std::memory_order order =                            \fB(4)\fP \fI(since C++11)\fP

                     std::memory_order_seq_cst ) volatile noexcept;

   Atomically replaces the current value with the result of arithmetic subtraction of
   the value and arg. That is, it performs atomic post-decrement. The operation is
   read-modify-write operation. Memory is affected according to the value of order.

   1,2) For signed integral types, arithmetic is defined to use two’s complement
   representation. There are no undefined results.

   For floating-point types, the floating-point environment in effect may
   be different from the calling thread's floating-point environment. The
   operation need not be conform to the corresponding std::numeric_limits \fI(since C++20)\fP
   traits but is encouraged to do so. If the result is not a
   representable value for its type, the result is unspecified but the
   operation otherwise has no undefined behavior.

   3,4) The result may be an undefined address, but the operation otherwise has no
   undefined behavior.
   If T is not a complete object type, the program is ill-formed.

   It is deprecated if std::atomic<T>::is_always_lock_free is false and   \fI(since C++20)\fP
   overload \fB(2)\fP or \fB(4)\fP participates in overload resolution.

.SH Parameters

   arg   - the other argument of arithmetic subtraction
   order - memory order constraints to enforce

.SH Return value

   The value immediately preceding the effects of this function in the modification
   order of *this.

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

     DR    Applied to              Behavior as published               Correct behavior
   P0558R1 C++11      arithmetic permitted on pointers to (possibly    made ill-formed
                      cv-qualified) void or function

.SH See also

   atomic_fetch_sub          subtracts a non-atomic value from an atomic object and
   atomic_fetch_sub_explicit obtains the previous value of the atomic
   \fI(C++11)\fP                   \fI(function template)\fP
   \fI(C++11)\fP
   operator++
   operator++(int)           increments or decrements the atomic value by one
   operator--                \fI(public member function)\fP
   operator--(int)
