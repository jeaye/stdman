.TH std::ranges::view::empty,std::ranges::empty_view 3 "2020.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::view::empty,std::ranges::empty_view \- std::ranges::view::empty,std::ranges::empty_view

.SH Synopsis
   template<class T>

       requires is_object_v<T>                               \fB(1)\fP \fI(since C++20)\fP

   class empty_view : public view_interface<empty_view<T>>
   namespace view {

   template<class T> inline constexpr empty_view<T> empty{}; \fB(2)\fP \fI(since C++20)\fP

   }

   1) A range adaptor that produces a View of no elements of a particular type.
   2) Variable template for empty_view.

.SH Member functions

std::ranges::empty_view::begin

   static constexpr T* begin() noexcept { return nullptr; }

   empty_view does not reference any element.

std::ranges::empty_view::end

   static constexpr T* end() noexcept { return nullptr; }

   empty_view does not reference any element.

std::ranges::empty_view::data

   static constexpr T* data() noexcept { return nullptr; }

   empty_view does not reference any element.

std::ranges::empty_view::size

   static constexpr std::ptrdiff_t size() noexcept { return 0; }

   empty_view is always empty.

std::ranges::empty_view::empty

   static constexpr bool empty() noexcept { return true; }

   empty_view is always empty.

.SH Non-member functions

begin, end(std::ranges::empty_view)

   friend constexpr T* begin(empty_view) noexcept { return nullptr; } \fB(1)\fP
   friend constexpr T* end(empty_view) noexcept { return nullptr; }   \fB(2)\fP

   These functions are not visible to ordinary unqualified or qualified lookup, and can
   only be found by argument-dependent lookup when std::ranges::empty_view<T> is an
   associated class of the arguments.

.SH Example

   
// Run this code

 #include <ranges>
  
 int main()
 {
     std::ranges::empty_view<int> e;
     static_assert(std::ranges::empty(e));
     static_assert(0 == e.size());
 }
