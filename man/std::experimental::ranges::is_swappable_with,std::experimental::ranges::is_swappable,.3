.TH std::experimental::ranges::is_swappable_with,std::experimental::ranges::is_swappable, 3 "2019.08.27" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::is_swappable_with,std::experimental::ranges::is_swappable, \- std::experimental::ranges::is_swappable_with,std::experimental::ranges::is_swappable,

.SH Synopsis
                     std::experimental::ranges::is_nothrow_swappable

   Defined in header <experimental/ranges/type_traits>
   template <class T, class U>                         \fB(1)\fP (ranges TS)
   struct is_swappable_with;
   template <class T>                                  \fB(2)\fP (ranges TS)
   struct is_swappable;
   template <class T, class U>                         \fB(3)\fP (ranges TS)
   struct is_nothrow_swappable_with;
   template <class T>                                  \fB(4)\fP (ranges TS)
   struct is_nothrow_swappable;

   1) If the expressions ranges::swap(std::declval<T>(), std::declval<U>()) and
   ranges::swap(std::declval<U>(), std::declval<T>()) are both well-formed when treated
   as an unevaluated operand, provides the member constant value equal true. Otherwise,
   value is false. Access checks are performed as if from a context unrelated to either
   type.
   2) If T is not a referenceable type (i.e., possibly cv-qualified void or a function
   type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value
   equal to false. Otherwise, provides a member constant value equal to
   ranges::is_swappable_with<T&, T&>::value.
   3) Same as \fB(1)\fP, but evaluations of both expressions from (1) are known not to throw
   exceptions.
   4) Same as \fB(2)\fP, but uses is_nothrow_swappable_with.

   T and U shall each be a complete type, (possibly cv-qualified) void, or an array of
   unknown bound. Otherwise, the behavior is undefined.

  Helper variable templates

   template <class T, class U>                                          \fB(1)\fP (ranges TS)
   constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
   template <class T>                                                   \fB(2)\fP (ranges TS)
   constexpr bool is_swappable_v = is_swappable<T>::value;
   template <class T, class U>
   constexpr bool is_nothrow_swappable_with_v =                         \fB(3)\fP (ranges TS)
   is_nothrow_swappable_with<T, U>::value;
   template <class T>
   constexpr bool is_nothrow_swappable_v =                              \fB(4)\fP (ranges TS)
   is_nothrow_swappable<T>::value;

Inherited from std::integral_constant

.SH Member constants

   value    true if T is swappable with U , false otherwise
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator bool converts the object to bool, returns value
                 \fI(public member function)\fP
   operator()    returns value
   \fI(C++14)\fP       \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type bool
   type       std::integral_constant<bool, value>

.SH Notes

   This trait does not check anything outside the immediate context of the swap
   expressions: if the use of T or U would trigger template specializations, generation
   of implicitly-defined special member functions etc, and those have errors, the
   actual swap may not compile even if ranges::is_swappable_with<T,U>::value compiles
   and evaluates to true.

.SH Examples

    This section is incomplete
    Reason: no example

.SH See also

   Swappable                 specifies that a type can be swapped or that two types can
   SwappableWith             be swapped with each other
                             (concept)
   is_swappable_with
   is_swappable
   is_nothrow_swappable_with checks if objects of a type can be swapped with objects of
   is_nothrow_swappable      same or different type
   \fI(C++17)\fP                   \fI(class template)\fP
   \fI(C++17)\fP
   \fI(C++17)\fP
   \fI(C++17)\fP
