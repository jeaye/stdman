.TH std::chrono::operator==,(std::chrono::year_month_day_last) 3 "2022.03.29" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::chrono::operator==,(std::chrono::year_month_day_last) \- std::chrono::operator==,(std::chrono::year_month_day_last)

.SH Synopsis
   Defined in header <chrono>
   constexpr bool operator==( const std::chrono::year_month_day_last&
   x,                                                                 \fB(1)\fP \fI(since C++20)\fP
   const std::chrono::year_month_day_last& y ) noexcept;
   constexpr std::strong_ordering

   operator<=>( const std::chrono::year_month_day_last& x,            \fB(2)\fP \fI(since C++20)\fP

   const std::chrono::year_month_day_last& y ) noexcept;

   Compares the two year_month_day_last values x and y. This is a lexicographical
   comparison: the year() is compared first, then month().

   The <, <=, >, >=, and != operators are synthesized from operator<=> and operator==
   respectively.

.SH Return value

   1) x.year() == y.year() && x.month() == y.month()
   2) x.year() <=> y.year() != 0 ? x.year() <=> y.year() : x.month() <=> y.month()

.SH Notes

   If both x and y represent valid dates (x.ok() && y.ok() == true), the result of the
   lexicographical comparison is consistent with the calendar order.

.SH Example


// Run this code

 #include <iostream>
 #include <chrono>

 int main()
 {
     std::cout << std::boolalpha;

     auto ymdl1 {11/std::chrono::last/2020};
     auto mdl {std::chrono::last/std::chrono::November};
     auto ymdl2 {mdl/2020};
     std::cout << (ymdl1 == ymdl2) << ' ';
     ymdl1 -= std::chrono::months{2};
     ymdl2 -= std::chrono::months{1};
     std::cout << (ymdl1 < ymdl2) << '\\n';
 }

.SH Output:

 true true
