.TH std::arg(std::complex) 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::arg(std::complex) \- std::arg(std::complex)

.SH Synopsis
   Defined in header <complex>
   template< class T >                          \fB(1)\fP
   T           arg( const std::complex<T>& z );
   Additional overloads \fI(since C++11)\fP
   Defined in header <complex>
   float       arg( float f );

   double      arg( double f );                         (until C++23)

   long double arg( long double f );
   template< class FloatingPoint >              (A)

   FloatingPoint                                        (since C++23)

               arg( FloatingPoint f );
   template< class Integer >                        (B)
   double      arg( Integer i );

   1) Calculates the phase angle (in radians) of the complex number z.

   A,B) Additional overloads are provided for all integer and
   floating-point types, which are treated as complex numbers with zero   \fI(since C++11)\fP
   imaginary component.

.SH Parameters

   z - complex value
   f - floating-point value
   i - integer value

.SH Return value

   1) std::atan2(std::imag(z), std::real(z)). If no errors occur, this is the phase
   angle of z in the interval [−π; π].
   A) Zero if f is positive or +0, π if f is negative or -0, NaN otherwise.
   B) Zero if i is non-negative, π if it is negative.

.SH Notes

   The additional overloads are not required to be provided exactly as (A,B). They only
   need to be sufficient to ensure that for their argument num:

     * If num has a
       standard
       (until C++23) floating-point type T, then std::arg(num) has the same effect as
       std::arg(std::complex<T>(num)).
     * Otherwise, if num has an integer type, then std::arg(num) has the same effect as
       std::arg(std::complex<double>(num)).

.SH Example


// Run this code

 #include <complex>
 #include <iostream>

 int main()
 {
     std::complex<double> z1(1, 0);
     std::complex<double> z2(0, 0);
     std::complex<double> z3(0, 1);
     std::complex<double> z4(-1, 0);
     std::complex<double> z5(-1, -0.0);
     double f = 1.;
     int i = -1;

     std::cout << "phase angle of " << z1 << " is " << std::arg(z1) << '\\n'
               << "phase angle of " << z2 << " is " << std::arg(z2) << '\\n'
               << "phase angle of " << z3 << " is " << std::arg(z3) << '\\n'
               << "phase angle of " << z4 << " is " << std::arg(z4) << '\\n'
               << "phase angle of " << z5 << " is " << std::arg(z5) << " "
                  "(the other side of the cut)\\n"
               << "phase angle of " << f << " is " << std::arg(f) << '\\n'
               << "phase angle of " << i << " is " << std::arg(i) << '\\n';

 }

.SH Output:

 phase angle of (1,0) is 0
 phase angle of (0,0) is 0
 phase angle of (0,1) is 1.5708
 phase angle of (-1,0) is 3.14159
 phase angle of (-1,-0) is -3.14159 (the other side of the cut)
 phase angle of 1 is 0
 phase angle of -1 is 3.14159

.SH See also

   abs(std::complex)    returns the magnitude of a complex number
                        \fI(function template)\fP
   polar                constructs a complex number from magnitude and phase angle
                        \fI(function template)\fP
   atan2
   atan2f               arc tangent, using signs to determine quadrants
   atan2l               \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   atan2(std::valarray) applies the function std::atan2 to a valarray and a value
                        \fI(function template)\fP
   C documentation for
   carg
