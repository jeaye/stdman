.TH std::experimental::static_pointer_cast,std::experimental::dynamic_pointer_cast, 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::static_pointer_cast,std::experimental::dynamic_pointer_cast, \- std::experimental::static_pointer_cast,std::experimental::dynamic_pointer_cast,

.SH Synopsis

   template< class T, class U >

   std::experimental::shared_ptr<T>                           \fB(1)\fP (library fundamentals
                                                                  TS)
       static_pointer_cast( const
   std::experimental::shared_ptr<U>& r ) noexcept;
   template< class T, class U >

   std::experimental::shared_ptr<T>                           \fB(2)\fP (library fundamentals
                                                                  TS)
       dynamic_pointer_cast( const
   std::experimental::shared_ptr<U>& r ) noexcept;
   template< class T, class U >

   std::experimental::shared_ptr<T>                           \fB(3)\fP (library fundamentals
                                                                  TS)
       const_pointer_cast( const
   std::experimental::shared_ptr<U>& r ) noexcept;
   template< class T, class U >

   std::experimental::shared_ptr<T>                           \fB(4)\fP (library fundamentals
                                                                  TS)
       reinterpret_pointer_cast( const
   std::experimental::shared_ptr<U>& r ) noexcept;

   Creates a new instance of std::experimental::shared_ptr whose stored pointer is
   obtained from r's stored pointer using a cast expression. If r is empty, so is the
   new shared_ptr (but its stored pointer is not necessarily null).

   Otherwise, the new shared_ptr will share ownership with r, except that it is empty
   if the dynamic_cast performed by dynamic_pointer_cast returns a null pointer.

   Let Y be typename std::experimental::shared_ptr<T>::element_type, then the resulting
   std::experimental::shared_ptr's stored pointer will be obtained by calling (in
   respective order):

   1) static_cast<Y*>(r.get()).
   2) dynamic_cast<Y*>(r.get()) (if the result of the dynamic_cast is a null pointer
   value, the returned shared_ptr will be empty).
   3) const_cast<Y*>(r.get()).
   4) reinterpret_cast<Y*>(r.get()).

   The behavior of these functions is undefined unless the corresponding cast from U*
   to T* is well formed:

   1) The behavior is undefined unless static_cast<T*>((U*)nullptr) is well formed.
   2) The behavior is undefined unless dynamic_cast<T*>((U*)nullptr) is well formed.
   3) The behavior is undefined unless const_cast<T*>((U*)nullptr) is well formed.
   4) The behavior is undefined unless reinterpret_cast<T*>((U*)nullptr) is well
   formed.

.SH Parameters

   r - the pointer to convert

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   constructor              constructs new shared_ptr
                            \fI(public member function)\fP
   static_pointer_cast
   dynamic_pointer_cast     applies static_cast, dynamic_cast, const_cast, or
   const_pointer_cast       reinterpret_cast to the stored pointer
   reinterpret_pointer_cast \fI(function template)\fP
   \fI(C++17)\fP

.SH Categories:
     * Noindexed pages
     * Todo no example
