.TH std::basic_streambuf::sgetn,std::basic_streambuf::xsgetn 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_streambuf::sgetn,std::basic_streambuf::xsgetn \- std::basic_streambuf::sgetn,std::basic_streambuf::xsgetn

.SH Synopsis
   std::streamsize sgetn( char_type* s, std::streamsize count );          \fB(1)\fP
   protected:                                                             \fB(2)\fP
   virtual std::streamsize xsgetn( char_type* s, std::streamsize count );

   1) Calls xsgetn(s, count) of the most derived class.
   2) Reads count characters from the input sequence and stores them into a character
   array pointed to by s. The characters are read as if by repeated calls to sbumpc().
   That is, if less than count characters are immediately available, the function calls
   uflow() to provide more until Traits::eof() is returned.
   Classes derived from std::basic_streambuf are permitted to provide more efficient
   implementations of this function.

.SH Parameters

   s     - pointer to the beginning of a char_type array
   count - maximum number of characters to read.

.SH Return value

   The number of characters successfully read. If it is less than count the input
   sequence has reached the end.

.SH Notes

   The rule about "more efficient implementations" permits bulk I/O without
   intermediate buffering: that's how std::ifstream::read simply passes the pointer to
   the POSIX read() system call in some implementations of iostreams

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   sputn invokes xsputn()
         \fI(public member function)\fP
