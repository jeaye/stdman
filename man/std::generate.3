.TH std::generate 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::generate \- std::generate

.SH Synopsis
   Defined in header <algorithm>
   template< class ForwardIt, class Generator >                           \fI(until C++20)\fP
   void generate( ForwardIt first, ForwardIt last, Generator g );
   template< class ForwardIt, class Generator >
   constexpr void generate( ForwardIt first, ForwardIt last,              \fI(since C++20)\fP
   Generator g );                                                 \fB(1)\fP
   template< class ExecutionPolicy, class ForwardIt, class
   Generator >                                                        \fB(2)\fP \fI(since C++17)\fP
   void generate( ExecutionPolicy&& policy, ForwardIt first,
   ForwardIt last, Generator g );

   1) Assigns each element in range [first, last) a value generated by the given
   function object g.
   2) Same as \fB(1)\fP, but executed according to policy. This overload only participates in
   overload resolution if std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is
   true.

.SH Parameters

   first, last - the range of elements to generate
   policy      - the execution policy to use. See execution policy for details.
                 generator function object that will be called.

                 The signature of the function should be equivalent to the following:
   g           -
                 Ret fun();

                 The type Ret must be such that an object of type ForwardIt can be
                 dereferenced and assigned a value of type Ret. 
.SH Type requirements
   -
   ForwardIt must meet the requirements of ForwardIterator.

.SH Return value

   \fI(none)\fP

.SH Complexity

   Exactly std::distance(first, last) invocations of g() and assignments.

.SH Exceptions

   The overload with a template parameter named ExecutionPolicy reports errors as
   follows:

     * If execution of a function invoked as part of the algorithm throws an exception
       and ExecutionPolicy is one of the three standard policies, std::terminate is
       called. For any other ExecutionPolicy, the behavior is implementation-defined.
     * If the algorithm fails to allocate memory, std::bad_alloc is thrown.

.SH Possible implementation

   template<class ForwardIt, class Generator>
   void generate(ForwardIt first, ForwardIt last, Generator g)
   {
       while (first != last) {
           *first++ = g();
       }
   }

.SH Example

   The following code fills a vector with random numbers:

   
// Run this code

 #include <algorithm>
 #include <iostream>
 #include <vector>
 #include <cstdlib>
  
 int main()
 {
     std::vector<int> v(5);
     std::srand(0); //Just for example
     std::generate(v.begin(), v.end(), std::rand); // Using the C function std::rand()
  
     std::cout << "v: ";
     for (auto iv: v) {
         std::cout << iv << " ";
     }
     std::cout << "\\n";
  
     // Initialize with default values 0,1,2,3,4 from a lambda function
     // Equivalent to std::iota(v.begin(), v.end(), 0);
     std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });
  
     std::cout << "v: ";
     for (auto iv: v) {
         std::cout << iv << " ";
     }
     std::cout << "\\n";
 }

.SH Possible output:

 v: 1804289383 846930886 1681692777 1714636915 1957747793
 v: 0 1 2 3 4

.SH See also

   fill       copy-assigns the given value to every element in a range
              \fI(function template)\fP 
   generate_n assigns the results of successive function calls to N elements in a range
              \fI(function template)\fP 
   iota       fills a range with successive increments of the starting value
   \fI(C++11)\fP    \fI(function template)\fP 
