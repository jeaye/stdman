.TH std::generate 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::generate \- std::generate

.SH Synopsis
   Defined in header <algorithm>
   template< class ForwardIt, class Generator >
   void generate( ForwardIt first, ForwardIt last,          \fB(1)\fP (constexpr since C++20)
   Generator g );
   template< class ExecutionPolicy, class ForwardIt, class
   Generator >

   void generate( ExecutionPolicy&& policy,                 \fB(2)\fP \fI(since C++17)\fP

                  ForwardIt first, ForwardIt last,
   Generator g );

   1) Assigns each element in range [first, last) a value generated by the given
   function object g.
   2) Same as \fB(1)\fP, but executed according to policy.
   This overload participates in overload resolution only if

   std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.        (until
                                                                             C++20)
   std::is_execution_policy_v<std::remove_cvref_t<ExecutionPolicy>> is true. (since
                                                                             C++20)

.SH Parameters

   first, last - the range of elements to generate
   policy      - the execution policy to use. See execution policy for details.
                 generator function object that will be called.

                 The signature of the function should be equivalent to the following:
   g           -
                 Ret fun();

                 The type Ret must be such that an object of type ForwardIt can be
                 dereferenced and assigned a value of type Ret.
.SH Type requirements
   -
   ForwardIt must meet the requirements of LegacyForwardIterator.

.SH Complexity

   Exactly std::distance(first, last) invocations of g() and assignments.

.SH Exceptions

   The overload with a template parameter named ExecutionPolicy reports errors as
   follows:

     * If execution of a function invoked as part of the algorithm throws an exception
       and ExecutionPolicy is one of the standard policies, std::terminate is called.
       For any other ExecutionPolicy, the behavior is implementation-defined.
     * If the algorithm fails to allocate memory, std::bad_alloc is thrown.

.SH Possible implementation

   template<class ForwardIt, class Generator>
   constexpr //< since C++20
   void generate(ForwardIt first, ForwardIt last, Generator g)
   {
       for (; first != last; ++first)
           *first = g();
   }

.SH Example


// Run this code

 #include <algorithm>
 #include <iostream>
 #include <vector>

 void println(std::string_view fmt, const auto& v)
 {
     for (std::cout << fmt; const auto& e : v)
         std::cout << e << ' ';
     std::cout << '\\n';
 };


 int f()
 {
     static int i;
     return ++i;
 }

 int main()
 {
     std::vector<int> v(5);

     std::generate(v.begin(), v.end(), f);
     println("v: ", v);

     // Initialize with default values 0,1,2,3,4 from a lambda function
     // Equivalent to std::iota(v.begin(), v.end(), 0);
     std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });
     println("v: ", v);
 }

.SH Output:

 v: 1 2 3 4 5
 v: 0 1 2 3 4

.SH See also

   fill             copy-assigns the given value to every element in a range
                    \fI(function template)\fP
                    assigns the results of successive function calls to N elements in a
   generate_n       range
                    \fI(function template)\fP
   iota             fills a range with successive increments of the starting value
   \fI(C++11)\fP          \fI(function template)\fP
   ranges::generate saves the result of a function in a range
   (C++20)          (niebloid)
