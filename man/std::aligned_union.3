.TH std::aligned_union 3 "Apr  2 2017" "2.1 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::aligned_union \- std::aligned_union

.SH Synopsis
   Defined in header <type_traits>
   template< std::size_t Len, class... Types >  \fI(since C++11)\fP
   struct aligned_union;

   Provides the member typedef type, which is a POD type of a size and alignment
   suitable for use as uninitialized storage for an object of any of the types listed
   in Types. The size of the storage is at least Len. std::aligned_union also
   determines the strictest (largest) alignment requirement among all Types and makes
   it available as the constant alignment_value.

   If sizeof...(Types) == 0, the behavior is undefined.

.SH Member types

   Name Definition
   type the POD type suitable for storage of any type from Types

.SH Helper types

   template< std::size_t Len, class... Types >                          \fI(since C++14)\fP
   using aligned_union_t = typename aligned_union<Len,Types...>::type;

.SH Member constants

   alignment_value the strictest alignment requirement of all Types
   \fB[static]\fP        \fI(public static member constant)\fP

.SH Possible implementation

   #include <algorithm>
   template <std::size_t Len, class... Types>
   struct aligned_union
   {
       static constexpr std::size_t alignment_value = std::max({alignof(Types)...});

       struct type
       {
         alignas(alignment_value) char _s[std::max({Len, sizeof(Types)...})];
       };
   };

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   alignment_of    obtains the type's alignment requirements
   \fI(C++11)\fP         \fI(class template)\fP
   aligned_storage defines the type suitable for use as uninitialized storage for types
   \fI(C++11)\fP         of given size
                   \fI(class template)\fP

.SH Category:

     * Todo no example
