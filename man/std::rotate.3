.TH std::rotate 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::rotate \- std::rotate

.SH Synopsis
   Defined in header <algorithm>
   template< class ForwardIt >
   void rotate( ForwardIt first, ForwardIt n_first, ForwardIt             \fI(until C++11)\fP
   last );
   template< class ForwardIt >
   ForwardIt rotate( ForwardIt first, ForwardIt n_first,          \fB(1)\fP     \fI(since C++11)\fP
   ForwardIt last );
   template< class ExecutionPolicy, class ForwardIt >
   ForwardIt rotate( ExecutionPolicy&& policy, ForwardIt first,       \fB(2)\fP \fI(since C++17)\fP
   ForwardIt n_first, ForwardIt last );

   1) Performs a left rotation on a range of elements.
   Specifically, std::rotate swaps the elements in the range [first, last) in such a
   way that the element n_first becomes the first element of the new range and n_first
   - 1 becomes the last element.
   A precondition of this function is that [first, n_first) and [n_first, last) are
   valid ranges.
   2) Same as \fB(1)\fP, but executed according to policy. This overload does not participate
   in overload resolution unless
   std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true

.SH Parameters

   first           -       the beginning of the original range
   n_first         -       the element that should appear at the beginning of the
                           rotated range
   last            -       the end of the original range
   policy          -       the execution policy to use. See execution policy for
                           details.
.SH Type requirements
   -
   ForwardIt must meet the requirements of ValueSwappable and ForwardIterator.
   -
   The type of dereferenced ForwardIt must meet the requirements of MoveAssignable and
   MoveConstructible.

.SH Return value

   \fI(none)\fP                                         \fI(until C++11)\fP
   The iterator equal to first + (last - n_first) \fI(since C++11)\fP

.SH Complexity

   Linear in the distance between first and last

.SH Exceptions

   The overload with a template parameter named ExecutionPolicy reports errors as
   follows:

     * If execution of a function invoked as part of the algorithm throws an exception
       and ExecutionPolicy is one of the three standard policies, std::terminate is
       called. For any other ExecutionPolicy, the behavior is implementation-defined.
     * If the algorithm fails to allocate memory, std::bad_alloc is thrown.

.SH Possible implementation

   template <class ForwardIt>
   ForwardIt rotate(ForwardIt first, ForwardIt n_first, ForwardIt last)
   {
       if(first == n_first) return last;
       if(n_first == last) return first;
    
       ForwardIt next = n_first;
    
       do {
           std::iter_swap(first++, next++);
           if (first == n_first) n_first = next;
       }
       while (next != last);
    
       ForwardIt ret = first;
    
       for(next = n_first; next != last; ) {
           std::iter_swap(first++, next++);
           if(first == n_first) n_first = next;
           else if(next == last) next = n_first;
       }
    
       return ret;
   }

.SH Example

   std::rotate is a common building block in many algorithms. This example demonstrates
   insertion sort:

   
// Run this code

 #include <vector>
 #include <iostream>
 #include <algorithm>
  
 int main()
 {
     std::vector<int> v{2, 4, 2, 0, 5, 10, 7, 3, 7, 1};
  
     std::cout << "before sort:      ";
     for (int n: v)
         std::cout << n << ' ';
     std::cout << '\\n';
  
     // insertion sort
     for (auto i = v.begin(); i != v.end(); ++i) {
         std::rotate(std::upper_bound(v.begin(), i, *i), i, i+1);
     }
  
     std::cout << "after sort:       ";
     for (int n: v)
         std::cout << n << ' ';
     std::cout << '\\n';
  
     // simple rotation to the left
     std::rotate(v.begin(), v.begin() + 1, v.end());
  
     std::cout << "simple rotate left  : ";
     for (int n: v)
         std::cout << n << ' ';
     std::cout << '\\n';
  
     // simple rotation to the right
     std::rotate(v.rbegin(), v.rbegin() + 1, v.rend());
  
     std::cout << "simple rotate right : ";
     for (int n: v)
         std::cout << n << ' ';
     std::cout << '\\n';
  
 }

.SH Output:

 before sort:      2 4 2 0 5 10 7 3 7 1
 after sort:       0 1 2 2 3 4 5 7 7 10
 simple rotate left : 1 2 2 3 4 5 7 7 10 0
 simple rotate right: 0 1 2 2 3 4 5 7 7 10

.SH See also

   rotate_copy copies and rotate a range of elements
               \fI(function template)\fP 
