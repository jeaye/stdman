.TH std::money_put::put,do_put 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::money_put::put,do_put \- std::money_put::put,do_put

.SH Synopsis
   Defined in header <locale>
   public:

   iter_type put(iter_type out, bool intl, std::ios_base& f,                  \fB(1)\fP

                 char_type fill, long double quant) const;
   iter_type put(iter_type out, bool intl, std::ios_base& f,                  \fB(2)\fP
                char_type fill, const string_type& quant) const;
   protected:

   virtual iter_type do_put(iter_type out, bool intl, std::ios_base& str,     \fB(3)\fP

                            char_type fill, long double units) const;
   virtual iter_type do_put(iter_type out, bool intl, std::ios_base& str,     \fB(4)\fP
                            char_type fill, const string_type& digits) const;

   Formats monetary value and writes the result to output stream.

   1-2) Public member functions, call the member function do_put of the most derived
   class.
   3) The numeric arguments units is converted to a wide character string as if by
   ct.widen(buf1, buf1 + std::sprintf(buf1, "%.0Lf", units), buf2), where ct is the
   std::ctype facet imbued in str.getloc() and buf1 and buf2 are sufficiently large
   character buffers. The resulting character string buf2 is processed, formatted, and
   output to out as desribed below.
   4) From the string argument digits, only the optional leading minus sign (as
   determined by comparing to ct.widen('-'), where ct is the std::ctype facet imbued in
   str.getloc()) and the immediately following digit characters (as classified by ct)
   are taken as the character sequence to be processed, formatted, and output to out as
   described below.

   Given the character sequence from the previous steps, if the first character equals
   ct.widen('-'), calls mp.neg_format() to obtain the formatting pattern, otherwise
   calls mp.pos_format(), where mp is the std::moneypunct<CharT, intl> facet imbued in
   str.getloc().

   Thousands separator and decimal point characters are inserted as required by
   mp.grouping(), mp.frac_digits(), mp.decimal_point(), and mp.thousands_sep(), and the
   resulting string is placed in the output sequence where value appears in the
   formatting pattern.

   If str.flags() & str.showbase is non-zero (the std::showbase manipulator was used),
   then the currency symbol or string is generated by calling mp.curr_symbol() and
   placed in the output sequence where symbol appears in the formatting pattern.

   If mp.positive_sign() (in case positive format pattern is used) or
   mp.negative_sign() (in case negative format pattern is used) returns a string with
   more than one character, the first character returned is placed in the output
   sequence where sign appears in the formatting pattern, and the rest of the
   characters are placed after all other characters, for example, formatting pattern
   {sign, value, space, symbol} with units 123 and negative_sign of "-" may result in
   "-1.23 €", while negative_sign of "()" would generate "(1.23 €)".

   If the number of characters generated for the specified format is less than the
   value returned by str.width(), then copies of fill are inserted to bring the total
   length of the output sequence to exactly str.width(), as follows:

     * If str.flags() & str.adjustfield equals str.internal, the fill characters are
       inserted where none or space appears in the formatting pattern.
     * Otherwise, if str.flags() & str.adjustfield equals str.left, the copies of fill
       are appended after all other characters
     * Otherwise, the fill characters are placed before all other characters.

   In the end, calls str.width\fB(0)\fP to cancel the effects of any std::setw.

.SH Return value

   An iterator pointing immediately after the last character produced

.SH Notes

   The currency units are assumed to be the smallest non-fractional units of the
   currency: cents in the U.S, yen in Japan.

.SH Example

   
// Run this code

 #include <iostream>
 #include <iomanip>
 #include <locale>
  
 struct my_punct : std::moneypunct_byname<char, false> {
     my_punct(const char* name) : moneypunct_byname(name) {}
     string_type do_negative_sign() const { return "()"; }
 };
  
 int main()
 {
     std::locale loc("ru_RU.utf8");
     std::cout.imbue(loc);
     long double units = -123.45;
     std::cout << "In Russian locale, " << units << " prints as "
               << std::showbase;
 // note, the following is equivalent to simply std::put_money(units)
     std::use_facet<std::money_put<char>>(loc).put(
              {std::cout}, false, std::cout, std::cout.fill(), units);
     std::cout << '\\n';
  
     std::cout.imbue(std::locale(std::cout.getloc(), new my_punct("ru_RU.utf8")));
     std::cout << "With negative_sign set to \\"()\\", it prints  as ";
     std::use_facet<std::money_put<char>>(loc).put(
              {std::cout}, false, std::cout, std::cout.fill(), units);
     std::cout << '\\n';
 }

.SH Output:

 In Russian locale, -123,45 prints as -1.23 руб
 With negative_sign set to "()", it prints  as (1.23 руб)

.SH See also

              defines monetary formatting parameters used by std::money_get and
   moneypunct std::money_put
              \fI(class template)\fP 
   money_get  parses and constructs a monetary value from an input character sequence
              \fI(class template)\fP 
   put_money  formats and outputs a monetary value
   \fI(C++11)\fP    \fI(function template)\fP 
