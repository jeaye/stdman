.TH std::array 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::array \- std::array

.SH Synopsis
   Defined in header <array>
   template<

       class T,               \fI(since C++11)\fP
       std::size_t N

   > struct array;

   std::array is a container that encapsulates fixed size arrays.

   This container is an aggregate type with the same semantics as a struct holding a
   C-style array T[N] as its only non-static data member. Unlike a C-style array, it
   doesn't decay to T* automatically. As an aggregate type, it can be initialized with
   aggregate-initialization given at most N initializers that are convertible to T:
   std::array<int, 3> a = {1,2,3};.

   The struct combines the performance and accessibility of a C-style array with the
   benefits of a standard container, such as knowing its own size, supporting
   assignment, random access iterators, etc.

   std::array satisfies the requirements of Container and ReversibleContainer except
   that default-constructed array is not empty and that the complexity of swapping is
   linear, satisfies the requirements of
   ContiguousContainer
   \fI(since C++17)\fP and partially satisfies the requirements of SequenceContainer.

   There is a special case for a zero-length array (N == 0). In that case,
   array.begin() == array.end(), which is some unique value. The effect of calling
   front() or back() on a zero-sized array is undefined.

   An array can also be used as a tuple of N elements of the same type.

.SH Member types

   Member type            Definition
   value_type             T 
   size_type              std::size_t 
   difference_type        std::ptrdiff_t 
   reference              value_type& 
   const_reference        const value_type& 
   pointer                value_type*
   const_pointer          const value_type*
                          RandomAccessIterator
   iterator               and LiteralType
                          \fI(since C++17)\fP
                          Constant RandomAccessIterator
   const_iterator         and LiteralType
                          \fI(since C++17)\fP 
   reverse_iterator       std::reverse_iterator<iterator> 
   const_reverse_iterator std::reverse_iterator<const_iterator> 

.SH Member functions

.SH Implicitly-defined member functions
                         initializes the array following the rules of aggregate
   constructor           initialization (note that default initialization may result in
   (implicitly declared) indeterminate values for non-class T)
                         \fI(public member function)\fP
   destructor            destroys every element of the array
   (implicitly declared) \fI(public member function)\fP
   operator=             overwrites every element of the array with the corresponding
   (implicitly declared) element of another array
                         \fI(public member function)\fP
.SH Element access
   at                    access specified element with bounds checking
                         \fI(public member function)\fP 
   operator[]            access specified element
                         \fI(public member function)\fP 
   front                 access the first element
                         \fI(public member function)\fP 
   back                  access the last element
                         \fI(public member function)\fP 
   data                  direct access to the underlying array
                         \fI(public member function)\fP 
.SH Iterators
   begin                 returns an iterator to the beginning
   cbegin                \fI(public member function)\fP 
   end                   returns an iterator to the end
   cend                  \fI(public member function)\fP 
   rbegin                returns a reverse iterator to the beginning
   crbegin               \fI(public member function)\fP 
   rend                  returns a reverse iterator to the end
   crend                 \fI(public member function)\fP 
.SH Capacity
   empty                 checks whether the container is empty
                         \fI(public member function)\fP 
   size                  returns the number of elements
                         \fI(public member function)\fP 
   max_size              returns the maximum possible number of elements
                         \fI(public member function)\fP 
.SH Operations
   fill                  fill the container with specified value
                         \fI(public member function)\fP 
   swap                  swaps the contents
                         \fI(public member function)\fP 

.SH Non-member functions

   operator==
   operator!=
   operator<             lexicographically compares the values in the array
   operator<=            \fI(function template)\fP 
   operator>
   operator>=
   std::get(std::array)  accesses an element of an array
                         \fI(function template)\fP 
   std::swap(std::array) specializes the std::swap algorithm
   \fI(C++11)\fP               \fI(function template)\fP 

.SH Helper classes

   std::tuple_size<std::array>    obtains the size of an array
                                  \fI(class template specialization)\fP 
   std::tuple_element<std::array> obtains the type of the elements of array
                                  \fI(class template specialization)\fP 

   Deduction guides\fI(since C++17)\fP

.SH Example

   
// Run this code

 #include <string>
 #include <iterator>
 #include <iostream>
 #include <algorithm>
 #include <array>
  
 int main()
 {
     // construction uses aggregate initialization
     std::array<int, 3> a1{ {1, 2, 3} }; // double-braces required in C++11 (not in C++14)
     std::array<int, 3> a2 = {1, 2, 3};  // never required after =
     std::array<std::string, 2> a3 = { std::string("a"), "b" };
  
     // container operations are supported
     std::sort(a1.begin(), a1.end());
     std::reverse_copy(a2.begin(), a2.end(),
                       std::ostream_iterator<int>(std::cout, " "));
  
     std::cout << '\\n';
  
     // ranged for loop is supported
     for(const auto& s: a3)
         std::cout << s << ' ';
 }

.SH Output:

 3 2 1
 a b

.SH See also

              Creates a std::array object whose size and optionally element type are
   make_array deduced from the arguments
              \fI(function template)\fP 
   to_array   Creates a std::array object from a built-in array
              \fI(function template)\fP 
