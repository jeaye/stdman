.TH std::numeric_limits::traps 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::traps \- std::numeric_limits::traps

.SH Synopsis
   static const bool traps      \fI(until C++11)\fP
   static constexpr bool traps  \fI(since C++11)\fP

   The value of std::numeric_limits<T>::traps is true for all arithmetic types T that
   have at least one value that, if used as an argument to an arithmetic operation,
   will generate a trap.

.SH Standard specializations

   T                     value of std::numeric_limits<T>::traps
   /* non-specialized */ false
   bool                  false
   char                  usually true
   signed char           usually true
   unsigned char         usually true
   wchar_t               usually true
   char16_t              usually true
   char32_t              usually true
   short                 usually true
   unsigned short        usually true
   int                   usually true
   unsigned int          usually true
   long                  usually true
   unsigned long         usually true
   long long             usually true
   unsigned long long    usually true
   float                 usually false
   double                usually false
   long double           usually false

.SH Notes

   On most platforms integer division by zero always traps, and
   std::numeric_limits<T>::traps is true for all integer types that support the value
   0. The exception is the type bool: even though division by false traps due to
   integral promotion from bool to int, it is the zero-valued int that traps. Zero is
   not a value of type bool.

   On most platforms, floating-point exceptions may be turned on and off at run time
   (e.g. feenableexcept() on Linux or _controlfp on Windows), in which case the value
   of std::numeric_limits<T>::traps for floating-point types reflects the state of
   floating-point trapping facility at the time of program startup, which is false on
   most modern systems. An exception would be a DEC Alpha program, where it is true if
   compiled without -ieee.

.SH See also

.SH Floating-point environment
   tinyness_before identifies floating-point types that detect tinyness before rounding
   \fB[static]\fP        \fI(public static member constant)\fP 
   has_denorm_loss identifies the floating-point types that detect loss of precision as
   \fB[static]\fP        denormalization loss rather than inexact result
                   \fI(public static member constant)\fP 
