.TH std::unordered_multimap::merge 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::unordered_multimap::merge \- std::unordered_multimap::merge

.SH Synopsis
   template<class H2, class P2>                                       \fB(1)\fP \fI(since C++17)\fP
   void merge(std::unordered_map<Key, T, H2, P2, Allocator>& source);
   template<class H2, class P2>
   void merge(std::unordered_map<Key, T, H2, P2, Allocator>&&         \fB(2)\fP \fI(since C++17)\fP
   source);
   template<class H2, class P2>
   void merge(std::unordered_multimap<Key, T, H2, P2, Allocator>&     \fB(3)\fP \fI(since C++17)\fP
   source);
   template<class H2, class P2>
   void merge(std::unordered_multimap<Key, T, H2, P2, Allocator>&&    \fB(4)\fP \fI(since C++17)\fP
   source);

   Attempts to extract ("splice") each element in source and insert it into *this using
   the hash function and key equality predicate of *this.

   No elements are copied or moved, only the internal pointers of the container nodes
   are repointed. All pointers and references to the transferred elements remain valid,
   but now refer into *this, not into source. Iterators referring to the transferred
   elements and all iterators referring to *this are invalidated.

   The behavior is undefined if get_allocator() != source.get_allocator().

.SH Parameters

   source - compatible container to transfer the nodes from

.SH Return value

   \fI(none)\fP

.SH Complexity

   Average case O(N), worst case O(N*size()+N), where N is source.size()

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   extract extracts nodes from the container
   \fI(C++17)\fP \fI(public member function)\fP 
           inserts elements
   insert  or nodes
           \fI(since C++17)\fP
           \fI(public member function)\fP 

.SH Category:

     * Todo no example
