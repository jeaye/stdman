.TH std::next 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::next \- std::next

.SH Synopsis
   Defined in header <iterator>
   template< class ForwardIt >

   ForwardIt next(                                                       \fI(since C++11)\fP
     ForwardIt it,                                                       \fI(until C++17)\fP

     typename std::iterator_traits<ForwardIt>::difference_type n = 1 );
   template< class InputIt >

   constexpr InputIt next(                                               \fI(since C++17)\fP
     InputIt it,

     typename std::iterator_traits<InputIt>::difference_type n = 1 );

   Return the nth successor of iterator it.

.SH Parameters

   it         -        an iterator
   n          -        number of elements to advance
.SH Type requirements
   -
   ForwardIt must meet the requirements of ForwardIterator.
   -
   InputIt must meet the requirements of InputIterator.

.SH Return value

   The nth successor of iterator it.

.SH Possible implementation

   template<class ForwardIt>
   ForwardIt next(ForwardIt it,
                  typename std::iterator_traits<ForwardIt>::difference_type n = 1)
   {
       std::advance(it, n);
       return it;
   }

.SH Notes

   Although the expression ++c.begin() often compiles, it is not guaranteed to do so:
   c.begin() is an rvalue expression, and there is no BidirectionalIterator requirement
   that specifies that increment of an rvalue is guaranteed to work. In particular,
   when iterators are implemented as pointers, ++c.begin() does not compile, while
   std::next(c.begin()) does.

.SH Example

   
// Run this code

 #include <iostream>
 #include <iterator>
 #include <vector>
  
 int main()
 {
     std::vector<int> v{ 3, 1, 4 };
  
     auto it = v.begin();
  
     auto nx = std::next(it, 2);
  
     std::cout << *it << ' ' << *nx << '\\n';
 }

.SH Output:

 3 4

.SH See also

   prev    decrement an iterator
   \fI(C++11)\fP \fI(function)\fP 
   advance advances an iterator by given distance
           \fI(function)\fP 
