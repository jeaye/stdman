.TH std::ranges::not_equal_to 3 "2019.08.27" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::not_equal_to \- std::ranges::not_equal_to

.SH Synopsis
   Defined in header <functional>
   struct not_equal_to;            \fI(since C++20)\fP

   Function object for performing comparisons. Deduces the parameter types of the
   function call operator from the arguments (but not the return type).

.SH Member types

   Member type    Definition
   is_transparent /* unspecified */

.SH Member functions

   operator() checks if the arguments are not equal
              \fI(public member function)\fP

std::ranges::not_equal_to::operator()

   template< class T, class U >

   requires EqualityComparableWith<T, U> ||
   /* std::declval<T>() == std::declval<U>() resolves to
   a built-in operator comparing pointers */

   constexpr bool operator()(T&& t, U&& u) const;

   Compares t and u. Equivalent to return !ranges::equal_to{}(std::forward<T>(t),
   std::forward<U>(u));.

.SH Notes

   Unlike std::not_equal_to, std::ranges::not_equal_to requires both == and != to be
   valid (via the EqualityComparableWith constraint), and is entirely defined in terms
   of std::ranges::equal_to. However, the implementation is free to use operator!=
   directly, because those concepts require the results of == and != to be consistent.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   not_equal_to function object implementing x != y
                \fI(class template)\fP
