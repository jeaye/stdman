.TH std::flat_multimap::flat_multimap 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::flat_multimap::flat_multimap \- std::flat_multimap::flat_multimap

.SH Synopsis
   flat_multimap()                                                   \fB(1)\fP  (since C++23)
       : flat_multimap(key_compare()) { }
   template< class Allocator >                                       \fB(2)\fP  (since C++23)
   flat_multimap( const flat_multimap&, const Allocator& alloc );
   template< class Allocator >                                       \fB(3)\fP  (since C++23)
   flat_multimap( flat_multimap&&, const Allocator& alloc );
   flat_multimap( key_container_type key_cont, mapped_container_type
   mapped_cont,                                                      \fB(4)\fP  (since C++23)
                  const key_compare& comp = key_compare() );
   template< class Allocator >

   flat_multimap( const key_container_type& key_cont,                \fB(5)\fP  (since C++23)
                  const mapped_container_type& mapped_cont,

                  const Allocator& alloc );
   template< class Allocator >

   flat_multimap( const key_container_type& key_cont,                \fB(6)\fP  (since C++23)
                  const mapped_container_type& mapped_cont,

                  const key_compare& comp, const Allocator& alloc );
   flat_multimap( std::sorted_equivalent_t, key_container_type
   key_cont,
                                                                     \fB(7)\fP  (since C++23)
                  mapped_container_type mapped_cont,

                  const key_compare& comp = key_compare() );
   template< class Allocator >

   flat_multimap( std::sorted_equivalent_t, const
   key_container_type& key_cont,                                     \fB(8)\fP  (since C++23)

                  const mapped_container_type& mapped_cont, const
   Allocator& alloc );
   template< class Allocator >

   flat_multimap( std::sorted_equivalent_t, const
   key_container_type& key_cont,                                     \fB(9)\fP  (since C++23)
                  const mapped_container_type& mapped_cont,

                  const key_compare& comp, const Allocator& alloc );
   explicit flat_multimap( const key_compare& comp )                 \fB(10)\fP (since C++23)
       : c(), compare(comp) { }
   template< class Allocator >                                       \fB(11)\fP (since C++23)
   flat_multimap( const key_compare& comp, const Allocator& alloc );
   template< class Allocator >                                       \fB(12)\fP (since C++23)
   explicit flat_multimap( const Allocator& alloc );
   template< class InputIter >

   flat_multimap( InputIter first, InputIter last,                   \fB(13)\fP (since C++23)
                  const key_compare& comp = key_compare() )

       : c(), compare(comp);
   template< class InputIter, class Allocator >

   flat_multimap( InputIter first, InputIter last,                   \fB(14)\fP (since C++23)

                  const key_compare& comp, const Allocator& alloc );
   template< class InputIter, class Allocator >
   flat_multimap( InputIter first, InputIter last, const Allocator&  \fB(15)\fP (since C++23)
   alloc );
   template< container-compatible-range<value_type> R >

   flat_multimap( std::from_range_t, R&& rg, const key_compare& comp \fB(16)\fP (since C++23)
   )

       : flat_multimap(comp);
   template< container-compatible-range<value_type> R >

   flat_multimap( std::from_range_t fr, R&& rg )                     \fB(17)\fP (since C++23)

       : flat_multimap(fr, std::forward<R>(rg), key_compare()) { }
   template< container-compatible-range<value_type> R, class
   Allocator >                                                       \fB(18)\fP (since C++23)
   flat_multimap( std::from_range_t, R&& rg, const Allocator& alloc
   );
   template< container-compatible-range<value_type> R, class
   Allocator >

   flat_multimap( std::from_range_t, R&& rg, const key_compare&      \fB(19)\fP (since C++23)
   comp,

                  const Allocator& alloc );
   template< class InputIter >

   flat_multimap( std::sorted_equivalent_t s, InputIter first,
   InputIter last,                                                   \fB(20)\fP (since C++23)
                  const key_compare& comp = key_compare() )

       : c(), compare(comp);
   template< class InputIter, class Allocator >

   flat_multimap( std::sorted_equivalent_t s, InputIter first,       \fB(21)\fP (since C++23)
   InputIter last,

                  const key_compare& comp, const Allocator& alloc );
   template< class InputIter, class Allocator >

   flat_multimap( std::sorted_equivalent_t s, InputIter first,       \fB(22)\fP (since C++23)
   InputIter last,

                  const Allocator& alloc );
   flat_multimap( std::initializer_list<value_type> init,

                  const key_compare& comp = key_compare() )          \fB(23)\fP (since C++23)

       : flat_multimap(init.begin(), init.end(), comp) { }
   template< class Allocator >

   flat_multimap( std::initializer_list<value_type> init, const      \fB(24)\fP (since C++23)
   key_compare& comp,

                  const Allocator& alloc );
   template< class Allocator >
   flat_multimap( std::initializer_list<value_type> init, const      \fB(25)\fP (since C++23)
   Allocator& alloc );
   flat_multimap( std::sorted_equivalent_t s,
   std::initializer_list<value_type> init,
                                                                     \fB(26)\fP (since C++23)
                  const key_compare& comp = key_compare() )

       : flat_multimap(s, init.begin(), init.end(), comp) { }
   template< class Allocator >

   flat_multimap( std::sorted_equivalent_t s,                        \fB(27)\fP (since C++23)
   std::initializer_list<value_type> init,

                  const key_compare& comp, const Allocator& alloc );
   template< class Allocator >

   flat_multimap( std::sorted_equivalent_t s,                        \fB(28)\fP (since C++23)
   std::initializer_list<value_type> init,

                  const Allocator& alloc );

   Constructs new container adaptor from a variety of data sources and optionally using
   user supplied comparison function object comp and/or allocator alloc.

   1) A default constructor. Constructs an empty container adaptor.
   2) A copy constructor. Constructs c with the copy of the contents of other.c and
   compare with other.compare. See allocator usage note below.
   3) A move constructor. Constructs the container adaptor with the contents of other
   using move semantics. See allocator usage note below.
   4) First, initializes c.keys with std::move(key_cont), c.values with
   std::move(mapped_cont), and compare with comp. Then sorts the underlying range
   [begin(), end()) with respect to value_comp().
   5) Same as \fB(4)\fP, equivalent to flat_multimap(key_cont, mapped_cont);. See allocator
   usage note below.
   6) Same as \fB(4)\fP, equivalent to flat_multimap(key_cont, mapped_cont, comp);. See
   allocator usage note below.
   7) Initializes c.keys with std::move(key_cont), c.values with
   std::move(mapped_cont), and compare with comp.
   8) Same as \fB(7)\fP, equivalent to flat_multimap(s, key_cont, mapped_cont);. See
   allocator usage note below.
   9) Same as \fB(7)\fP, equivalent to flat_multimap(s, key_cont, mapped_cont, comp);. See
   allocator usage note below.
   10) Constructs an empty container adaptor.
   11,12) Constructs an empty container adaptor. See allocator usage note below.
   13) Constructs the container adaptor with the contents of the range [first, last),
   equivalent to insert(first, last);.
   14,15) Same as \fB(13)\fP. See allocator usage note below.
   16) Constructs the container adaptor with the contents of the range rg. First, uses
   \fB(10)\fP as delegating constructor. Then initializes c with the contents of rg as if by
   insert_range(std::forward<R>(rg));.
   17) Same as \fB(16)\fP using it as delegating constructor.
   18,19) Same as \fB(16)\fP. See allocator usage note below.
   20) Constructs the underlying containers with the contents of the range
   [first, last) as if by insert(first, last).
   21,22) Same as \fB(20)\fP. See allocator usage note below.
   23) An initializer-list constructor. Constructs the underlying container with the
   contents of the initializer list init, using \fB(13)\fP as delegating constructor.
   24,25) Same as \fB(23)\fP. See allocator usage note below.
   26) An initializer-list constructor. Constructs the underlying container with the
   contents of the initializer list init, using \fB(20)\fP as delegating constructor.
   27,28) Save as \fB(26)\fP. See allocator usage note below.

   Note for overloads (13-15,20-22): If [first, last) is not a valid range, the
   behavior is undefined.

.SH Parameters

   key_cont    - a container to be used as source to initialize the underlying keys
                 container
   mapped_cont - a container to be used as source to initialize the underlying values
                 container
   other       - another flat_multimap to be used as source to initialize the elements
                 of the underlying containers with
   alloc       - an allocator to use for all memory allocations of the underlying
                 containers
   comp        - a function object to be used for all comparisons of keys
   first, last - a range to copy the elements from
   init        - an initializer list to initialize the elements of the underlying
                 containers with
                 a container compatible range (that is, an input_range whose elements
   rg          - are convertible to value_type) to be used as source to initialize the
                 underlying containers
   fr          - a disambiguation tag that indicates that the contained member should
                 be range constructed
   s           - a disambiguation tag that indicates that the input sequence is sorted
                 with respect to value_comp()
.SH Type requirements
   -
   InputIt must meet the requirements of LegacyInputIterator.
   -
   Compare must meet the requirements of Compare.
   -
   Allocator must meet the requirements of Allocator.

.SH Complexity

   1) Constant.
   2) Linear in size of other.
   3) Same as the corresponding move-constructor of the wrapped container, i.e.
   constant or linear in size of cont.
   4-6) Linear in \\(\\scriptsize N\\)N if cont is sorted with respect to value_comp(),
   otherwise \\(\\scriptsize \\mathcal{O}(N\\cdot\\log{(N)})\\)(N路log(N)), where
   \\(\\scriptsize N\\)N is the value of key_cont.size() before this call.
   7-9) Same as the corresponding move-constructor of the wrapped container, i.e.
   constant or linear in size of cont.
   10-12) Constant.
   13-15) Linear in \\(\\scriptsize N\\)N if the input range [first, last) is sorted with
   respect to value_comp(), otherwise \\(\\scriptsize
   \\mathcal{O}(N\\cdot\\log{(N)})\\)(N路log(N)), where \\(\\scriptsize N\\)N is the value of
   key_cont.size() before this call.
   16-19) Linear in \\(\\scriptsize N\\)N if the input range rg is sorted with respect to
   value_comp(), otherwise \\(\\scriptsize \\mathcal{O}(N\\cdot\\log{(N)})\\)(N路log(N)),
   where \\(\\scriptsize N\\)N is the value of key_cont.size() before this call.
   20-22) Linear in size of [first, last).
   23-25) Linear in \\(\\scriptsize N\\)N if the elements of init are sorted with respect
   to value_comp(), otherwise \\(\\scriptsize \\mathcal{O}(N\\cdot\\log{(N)})\\)(N路log(N)),
   where \\(\\scriptsize N\\)N is the value of key_cont.size() before this call.
   26-28) Linear in size of init.

.SH Exceptions

   Calls to Allocator::allocate may throw.

.SH Notes

   After container move construction (overload \fB(3)\fP), references, pointers, and
   iterators (other than the end iterator) to other remain valid, but refer to elements
   that are now in *this. The current standard makes this guarantee via the blanket
   statement in [container.reqmts]/67, and a more direct guarantee is under
   consideration via LWG issue 2321.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   operator= assigns values to the container adaptor
             \fI(public member function)\fP

.SH Category:
     * Todo no example
