.TH std::atomic_ref::operator+=,-= 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic_ref::operator+=,-= \- std::atomic_ref::operator+=,-=

.SH Synopsis
   member only of atomic_ref<Integral> and atomic_ref<Floating>
   specializations
   T operator+=( T arg ) const noexcept;                              \fB(1)\fP \fI(since C++20)\fP
   T operator-=( T arg ) const noexcept;                              \fB(2)\fP \fI(since C++20)\fP
   member only of atomic_ref<T*> partial specialization
   T* operator+=( std::ptrdiff_t arg ) const noexcept;                \fB(3)\fP \fI(since C++20)\fP
   T* operator-=( std::ptrdiff_t arg ) const noexcept;                \fB(4)\fP \fI(since C++20)\fP

   Atomically replaces the current value of the referenced object with the result of
   computation involving the previous value and arg. These operations are
   read-modify-write operations.

     * operator+= performs atomic addition. Equivalent to return fetch_add(arg) + arg;.
     * operator-= performs atomic subtraction. Equivalent to return fetch_sub(arg) -
       arg;.
   1,2) For signed integral types, arithmetic is defined to use twoâ€™s complement
   representation. There are no undefined results.
   For floating-point types, the floating-point environment in effect may be different
   from the calling thread's floating-point environment. The operation need not be
   conform to the corresponding std::numeric_limits traits but is encouraged to do so.
   If the result is not a representable value for its type, the result is unspecified
   but the operation otherwise has no undefined behavior.
   3,4) The result may be an undefined address, but the operations otherwise have no
   undefined behavior. The program is ill-formed if T is not an object type.

.SH Parameters

   arg - the argument for the arithmetic operation

.SH Return value

   The resulting value (that is, the result of applying the corresponding binary
   operator to the value immediately preceding the effects of the corresponding member
   function).

.SH Notes

   Unlike most compound assignment operators, the compound assignment operators for
   atomic_ref do not return a reference to their left-hand arguments. They return a
   copy of the stored value instead.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

                   atomically adds the argument to the value stored in the referenced
   fetch_add       object and obtains the value held previously
                   \fI(public member function)\fP
                   atomically subtracts the argument from the value stored in the
   fetch_sub       referenced object and obtains the value held previously
                   \fI(public member function)\fP
   operator++
   operator++(int) atomically increments or decrements the referenced object by one
   operator--      \fI(public member function)\fP
   operator--(int)
   operator&=      atomically performs bitwise AND, OR, XOR with the referenced value
   operator|=      \fI(public member function)\fP
   operator^=

.SH Category:
     * Todo no example
