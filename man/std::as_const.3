.TH std::as_const 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::as_const \- std::as_const

.SH Synopsis
   Defined in header <utility>
   template <class T>                                      \fB(1)\fP \fI(since C++17)\fP
   constexpr std::add_const_t<T>& as_const(T& t) noexcept;
   template <class T>                                      \fB(2)\fP \fI(since C++17)\fP
   void as_const(const T&&) = delete;

   1) Forms lvalue reference to const type of t
   2) const rvalue reference overload is deleted to disallow rvalue arguments

.SH Possible implementation

   template <class T>
   constexpr std::add_const_t<T>& as_const(T& t) noexcept
   {
       return t;
   }

.SH Example

   
// Run this code

 #include <string>
 #include <cassert>
 #include <utility>
 #include <type_traits>
  
 int main()
 {
     std::string mutableString = "Hello World!";
     const std::string& constView = std::as_const(mutableString);
  
     assert( &constView == &mutableString );
     assert( &std::as_const( mutableString ) == &mutableString );
  
     using WhatTypeIsIt = std::remove_reference_t<decltype(std::as_const(mutableString))>;
  
     static_assert(std::is_same<std::remove_const_t<WhatTypeIsIt>, std::string>::value,
             "WhatTypeIsIt should be some kind of string." );
     static_assert(!std::is_same< WhatTypeIsIt, std::string >::value,
             "WhatTypeIsIt shouldn't be a mutable string." );
 }

.SH See also

   is_const        checks if a type is const-qualified
   \fI(C++11)\fP         \fI(class template)\fP 
   add_cv
   add_const
   add_volatile    adds const or/and volatile specifiers to the given type
   \fI(C++11)\fP         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   remove_cv
   remove_const
   remove_volatile removes const or/and volatile specifiers from the given type
   \fI(C++11)\fP         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
