.TH std::adjacent_difference 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::adjacent_difference \- std::adjacent_difference

.SH Synopsis
   Defined in header <numeric>
   template< class InputIt, class OutputIt >

   OutputIt adjacent_difference( InputIt first,
   InputIt last,                                            (until C++20)

                                 OutputIt d_first
   );
   template< class InputIt, class OutputIt >

   constexpr OutputIt adjacent_difference( InputIt
   first, InputIt last,                                     (since C++20)

                                           OutputIt
   d_first );
   template< class ExecutionPolicy, class
   ForwardIt1, class ForwardIt2 >

   ForwardIt2 adjacent_difference(
   ExecutionPolicy&& policy, ForwardIt1 first,          \fB(2)\fP \fI(since C++17)\fP
   ForwardIt1 last,

                                   ForwardIt2
   d_first );
   template< class InputIt, class OutputIt, class
   BinaryOperation >                                \fB(1)\fP

   OutputIt adjacent_difference( InputIt first,                           (until C++20)
   InputIt last,

                                 OutputIt d_first,
   BinaryOperation op );
   template< class InputIt, class OutputIt, class
   BinaryOperation >

   constexpr OutputIt adjacent_difference( InputIt                        (since C++20)
   first, InputIt last,                                 \fB(3)\fP

                                           OutputIt
   d_first, BinaryOperation op );
   template< class ExecutionPolicy, class
   ForwardIt1, class ForwardIt2, class
   BinaryOperation >

   ForwardIt2 adjacent_difference(                          \fB(4)\fP           \fI(since C++17)\fP
   ExecutionPolicy&& policy, ForwardIt1 first,
   ForwardIt1 last,

                                   ForwardIt2
   d_first, BinaryOperation op );

   Computes the differences between the second and the first of each adjacent pair of
   elements of the range [first, last) and writes them to the range beginning at
   d_first + 1. An unmodified copy of *first is written to *d_first.

   1,3) First, creates an accumulator acc whose type is InputIt's value type,
   initializes it with *first, and assigns the result to *d_first. Then, for every
   iterator i in [first + 1, last) in order, creates an object val whose type is
   InputIt's value type, initializes it with *i, computes val - acc (overload \fB(1)\fP) or
   op(val, acc) (overload \fB(3)\fP), assigns the result to *(d_first + (i - first)), and
   move assigns from val to acc.
   first may be equal to d_first.
   2,4) First, creates an object whose type is ForwardIt1's value type, initializes it
   with *first, and assigns the result to *d_first. Then for every d in [1, last -
   first - 1], creates an object val whose type is ForwardIt1's value type, initializes
   it with *(first + d) - *(first + d - 1) (overload \fB(2)\fP) or op(*(first + d), *(first +
   d - 1)) (overload \fB(4)\fP), and assigns the result to *(d_first + d). This is executed
   according to policy. This overload only participates in overload resolution if
   std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.
   The behavior is undefined if the input and output ranges overlap in any way.

   Equivalent operation:

 *(d_first)   = *first;
 *(d_first+1) = *(first+1) - *(first);
 *(d_first+2) = *(first+2) - *(first+1);
 *(d_first+3) = *(first+3) - *(first+2);
 ...

   op must not have side effects.                                         \fI(until C++11)\fP
   op must not invalidate any iterators, including the end iterators, or  \fI(since C++11)\fP
   modify any elements of the ranges involved.

.SH Parameters

   first, last - the range of elements
   d_first     - the beginning of the destination range
   policy      - the execution policy to use. See execution policy for details.
                 binary operation function object that will be applied.

                 The signature of the function should be equivalent to the following:

                  Ret fun(const Type1 &a, const Type2 &b);
   op          -
                 The signature does not need to have const &.
                 The types Type1 and Type2 must be such that an object of type
                 iterator_traits<InputIt>::value_type can be implicitly converted to
                 both of them. The type Ret must be such that an object of type
                 OutputIt can be dereferenced and assigned a value of type Ret. 
.SH Type requirements
   -
   InputIt must meet the requirements of InputIterator. InputIt's value type must be
   MoveAssignable and constructible from the type of *first
   -
   OutputIt must meet the requirements of OutputIterator. both acc (the accumulated
   value) and the result of val-acc or op(val, acc) must be writable to OutputIt
   -
   ForwardIt1, ForwardIt2 must meet the requirements of ForwardIterator. ForwardIt1's
   value_type must be CopyConstructible, constructible from the expression *first -
   *first or op(*first, *first), and assignable to ForwardIt2's value_type

.SH Return value

   Iterator pointing just past the last element written.

.SH Notes

   If first == last, this function has no effect and will merely return d_first.

.SH Complexity

   Exactly (last - first) - 1 applications of the binary operation

.SH Exceptions

   The overloads with a template parameter named ExecutionPolicy report errors as
   follows:

     * If execution of a function invoked as part of the algorithm throws an exception
       and ExecutionPolicy is one of the three standard policies, std::terminate is
       called. For any other ExecutionPolicy, the behavior is implementation-defined.
     * If the algorithm fails to allocate memory, std::bad_alloc is thrown.

.SH Possible implementation

.SH First version
   template<class InputIt, class OutputIt>
   OutputIt adjacent_difference(InputIt first, InputIt last,
                                OutputIt d_first)
   {
       if (first == last) return d_first;
    
       typedef typename std::iterator_traits<InputIt>::value_type value_t;
       value_t acc = *first;
       *d_first = acc;
       while (++first != last) {
           value_t val = *first;
           *++d_first = val - acc;
           acc = std::move(val);
       }
       return ++d_first;
   }
.SH Second version
   template<class InputIt, class OutputIt, class BinaryOperation>
   OutputIt adjacent_difference(InputIt first, InputIt last,
                                OutputIt d_first, BinaryOperation op)
   {
       if (first == last) return d_first;
    
       typedef typename std::iterator_traits<InputIt>::value_type value_t;
       value_t acc = *first;
       *d_first = acc;
       while (++first != last) {
           value_t val = *first;
           *++d_first = op(val, acc);
           acc = std::move(val);
       }
       return ++d_first;
   }

.SH Example

   
// Run this code

 #include <numeric>
 #include <vector>
 #include <iostream>
 #include <functional>
  
 int main()
 {
     // Default implementation - the difference b/w two adjacent items
  
     std::vector<int> v{2, 4, 6, 8, 10, 12, 14, 16, 18, 20};
     std::adjacent_difference(v.begin(), v.end(), v.begin());
  
     for (auto n : v) {
         std::cout << n << ' ';
     }
     std::cout << '\\n';
  
     // Fibonacci
     // Notice, next item on the list is the result of the current iteration
  
     v = std::vector<int>(10);
     v[0] = 1;
  
     std::adjacent_difference(v.begin(), v.end() - 1, v.begin() + 1, std::plus<int>());
  
     for (auto n : v) {
         std::cout << n << ' ';
     }
     std::cout << '\\n';
 }

.SH Output:

 2 2 2 2 2 2 2 2 2 2
 1 1 2 3 5 8 13 21 34 55

.SH See also

   partial_sum computes the partial sum of a range of elements
               \fI(function template)\fP 
   accumulate  sums up a range of elements
               \fI(function template)\fP 
