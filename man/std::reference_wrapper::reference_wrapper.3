.TH std::reference_wrapper::reference_wrapper 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::reference_wrapper::reference_wrapper \- std::reference_wrapper::reference_wrapper

.SH Synopsis
   reference_wrapper( T& x ) noexcept;                                   (until C++20)
   reference_wrapper( T&& x ) = delete;
   template< class U >                                           \fB(1)\fP     (since C++20)
   reference_wrapper( U&& x ) noexcept(/*see below*/) ;
   reference_wrapper( const reference_wrapper& other ) noexcept;     \fB(2)\fP

   Constructs a new reference wrapper.

   1) Stores a reference to x. Construction from a temporary object is    (until C++20)
   not allowed.
   1) Converts x to T& as if by T& t = std::forward<U>(x);, then stores a
   reference to t. This overload only participates in overload resolution
   if std::is_same_v<std::remove_cvref_t<U>, reference_wrapper> is false
   and the expression FUN(std::declval<U>()) is well-formed, where FUN    (since C++20)
   names the set of imaginary functions

   void FUN(T&) noexcept;
   void FUN(T&&) = delete;

   2) Copy constructor. Stores a reference to other.get().

.SH Parameters

   x     - an object to wrap
   other - another reference wrapper

.SH Exceptions

   1)
   noexcept specification:  
   noexcept(noexcept(FUN(std::declval<U>())))                             (since C++20)
   where FUN is the set of imaginary functions described in the
   description above.

.SH Notes

   The pre-C++20 deleted constructor from T&& still participates in the formation of
   implicit conversion sequences, which can lead to unexpected results in overload
   resolution. The C++20 change (via LWG issue 2993) rectifies this problem.

.SH Category:

     * conditionally noexcept
