.TH std::integer_sequence 3 "Apr  2 2017" "2.1 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::integer_sequence \- std::integer_sequence

.SH Synopsis
   Defined in header <utility>
   template< class T, T... Ints >  \fI(since C++14)\fP
   class integer_sequence;

   The class template std::integer_sequence represents a compile-time sequence of
   integers. When used as an argument to a function template, the parameter pack Ints
   can be deduced and used in pack expansion.

.SH Template parameters

   T       - an integer type to use for the elements of the sequence
   ...Ints - a non-type parameter pack representing the sequence

.SH Member types

   Member type Definition
   value_type  T

.SH Member functions

   size     returns the number of elements in Ints
   \fB[static]\fP \fI(public static member function)\fP

std::integer_sequence::size

   static constexpr std::size_t size();

   Returns the number of elements in Ints. Equivalent to sizeof...(Ints)

.SH Parameters

   \fI(none)\fP

.SH Return value

   The number of elements in Ints.

.SH Exceptions

   noexcept specification:
   noexcept

  Helper templates

   A helper alias template std::index_sequence is defined for the common case where T
   is std::size_t.

   template<std::size_t... Ints>
   using index_sequence = std::integer_sequence<std::size_t, Ints...>;

   A helper alias template std::make_integer_sequence is defined to simplify creation
   of std::integer_sequence and std::index_sequence types with 0, 1, 2, ..., N-1 as
   Ints:

   template<class T, T N>
   using make_integer_sequence = std::integer_sequence<T, /* a sequence 0, 1, 2, ...,
   N-1 */ >;
   template<std::size_t N>
   using make_index_sequence = make_integer_sequence<std::size_t, N>;

   The program is ill-formed if N is negative. If N is zero, the indicated type is
   integer_sequence<T>.

   A helper alias template std::index_sequence_for is defined to convert any type
   parameter pack into an index sequence of the same length

   template<class... T>
   using index_sequence_for = std::make_index_sequence<sizeof...(T)>;

.SH Example

   
// Run this code

 #include <tuple>
 #include <iostream>
 #include <array>
 #include <utility>

 // Convert array into a tuple
 template<typename Array, std::size_t... I>
 decltype(auto) a2t_impl(const Array& a, std::index_sequence<I...>)
 {
     return std::make_tuple(a[I]...);
 }

 template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
 decltype(auto) a2t(const std::array<T, N>& a)
 {
     return a2t_impl(a, Indices());
 }

 // pretty-print a tuple (from http://stackoverflow.com/a/6245777/273767)

 template<class Ch, class Tr, class Tuple, std::size_t... Is>
 void print_tuple_impl(std::basic_ostream<Ch,Tr>& os,
                       const Tuple & t,
                       std::index_sequence<Is...>)
 {
     using swallow = int[]; // guarantees left to right order
     (void)swallow{0, (void(os << (Is == 0? "" : ", ") << std::get<Is>(t)), 0)...};
 }

 template<class Ch, class Tr, class... Args>
 decltype(auto) operator<<(std::basic_ostream<Ch, Tr>& os,
                           const std::tuple<Args...>& t)
 {
     os << "(";
     print_tuple_impl(os, t, std::index_sequence_for<Args...>{});
     return os << ")";
 }

 int main()
 {
     std::array<int, 4> array = {1,2,3,4};

     // convert an array into a tuple
     auto tuple = a2t(array);
     static_assert(std::is_same<decltype(tuple),
                                std::tuple<int, int, int, int>>::value, "");

     // print it to cout
     std::cout << tuple << '\\n';
 }

.SH Output:

 (1, 2, 3, 4)

.SH Example

   This example shows how a std::tuple can be converted into arguments for a function
   invocation (see std::experimental::apply).

   
// Run this code

 #include <iostream>
 #include <tuple>
 #include <utility>

 template<typename Func, typename Tup, std::size_t... index>
 decltype(auto) invoke_helper(Func&& func, Tup&& tup, std::index_sequence<index...>)
 {
     return func(std::get<index>(std::forward<Tup>(tup))...);
 }

 template<typename Func, typename Tup>
 decltype(auto) invoke(Func&& func, Tup&& tup)
 {
     constexpr auto Size = std::tuple_size<typename std::decay<Tup>::type>::value;
     return invoke_helper(std::forward<Func>(func),
                          std::forward<Tup>(tup),
                          std::make_index_sequence<Size>{});
 }

 void foo(int a, const std::string& b, float c)
 {
     std::cout << a << " , " << b << " , " << c << '\\n';
 }

 int main()
 {
     auto args = std::make_tuple(2, "Hello", 3.5);
     invoke(foo, args);
 }

.SH Output:

 2 , Hello , 3.5

.SH Category:

     * unconditionally noexcept
