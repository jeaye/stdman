.TH std::wmemmove 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::wmemmove \- std::wmemmove

.SH Synopsis
   Defined in header <cwchar>
   wchar_t* wmemmove( wchar_t* dest, const wchar_t* src, std::size_t count );

   Copies exactly count successive wide characters from the wide character array
   pointed to by src to the wide character array pointed to by dest.

   If count is zero, the function does nothing.

   The arrays may overlap: copying takes place as if the wide characters were copied to
   a temporary wide character array and then copied from the temporary array to dest.

.SH Parameters

   dest  - pointer to the wide character array to copy to
   src   - pointer to the wide character array to copy from
   count - number of wide characters to copy

.SH Return value

   Returns a copy of dest

.SH Notes

   This function is not locale-sensitive and pays no attention to the values of the
   wchar_t objects it copies: nulls as well as invalid characters are copied too.

.SH Example

   
// Run this code

 #include <iostream>
 #include <cwchar>
 #include <locale>
 #include <clocale>
  
 int main()
 {
     std::setlocale(LC_ALL, "en_US.utf8");
     std::wcout.imbue(std::locale("en_US.utf8"));
  
     wchar_t str[] = L"αβγδεζηθικλμνξοπρστυφχψω";
     std::wcout << str << '\\n';
     std::wmemmove(str+4, str+3, 3); // copy from [δεζ] to [εζη]
     std::wcout << str << '\\n';
 }

.SH Possible output:

 αβγδεζηθικλμνξοπρστυφχψω
 αβγδδεζθικλμνξοπρστυφχψω

.SH See also

                 copies a certain amount of wide characters between two non-overlapping
   wmemcpy       arrays
                 \fI(function)\fP 
   memmove       moves one buffer to another
                 \fI(function)\fP 
   copy          copies a range of elements to a new location
   copy_if       \fI(function template)\fP 
   \fI(C++11)\fP
   copy_backward copies a range of elements in backwards order
                 \fI(function template)\fP 
   C documentation for
   wmemmove
