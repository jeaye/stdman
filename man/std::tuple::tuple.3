.TH std::tuple::tuple 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::tuple::tuple \- std::tuple::tuple

.SH Synopsis
Defined in header
<tuple>
                              (since
constexpr tuple();            C++11)
                              (until
                              C++17)
/*EXPLICIT*/                  (since
constexpr tuple();            C++17)
                                     (since
explicit tuple( const                C++11)
Types&... args );                    (until
                                     C++14)
explicit constexpr                   (since
tuple( const                         C++14)
Types&... args );                    (until
                                     C++17)
/*EXPLICIT*/
constexpr tuple(                     (since
const Types&... args                 C++17)
);
template< class...                          (since
UTypes >                                    C++11)
explicit tuple(                             (until
UTypes&&... args );                         C++14)
template< class...                          (since
UTypes >                                    C++14)
explicit constexpr                          (until
tuple( UTypes&&...                          C++17)
args );
template< class...
UTypes >                                    (since
/*EXPLICIT*/                                C++17)
constexpr tuple(
UTypes&&... args );
template< class...                                 (since
UTypes >                                           C++11)
tuple( const                                       (until
tuple<UTypes...>&                                  C++14)
other );
template< class...
UTypes >                                           (since
constexpr tuple(                                   C++14)
const                                              (until
tuple<UTypes...>&                                  C++17)
other );
template< class...
UTypes >
/*EXPLICIT*/                                       (since
constexpr tuple(                                   C++17)
const
tuple<UTypes...>&
other );
template <class...                                        (since
UTypes>                                                   C++11)
tuple(                                                    (until
tuple<UTypes...>&&                                        C++14)
other );
template <class...                                        (since
UTypes>                                                   C++14)
constexpr tuple(                                          (until
tuple<UTypes...>&&                                        C++17)
other );
template <class...
UTypes>
/*EXPLICIT*/                                              (since
constexpr tuple(                                          C++17)
tuple<UTypes...>&&
other );
template< class U1,                                              (since
class U2 >                                                       C++11)
tuple( const                                                     (until
pair<U1,U2>& p );                                                C++14)
template< class U1,                                              (since
class U2 >                                                       C++14)
constexpr tuple(                                                 (until
const pair<U1,U2>& p                                             C++17)
);
template< class U1,
class U2 >
/*EXPLICIT*/                                                     (since
constexpr tuple(                                                 C++17)
const pair<U1,U2>& p
);
template< class U1,                                                     (since
class U2 >                                                              C++11)
tuple( pair<U1,U2>&&                                                    (until
p );                                                                    C++14)
template< class U1,                                                     (since
class U2 >                                                              C++14)
constexpr tuple(                                                        (until
pair<U1,U2>&& p );                                                      C++17)
template< class U1,
class U2 >                                                              (since
/*EXPLICIT*/                                                            C++17)
constexpr tuple(
pair<U1,U2>&& p );
tuple( const tuple&                                              \fB(8)\fP    (since
other ) = default;                                                      C++11)
tuple( tuple&& other                                             \fB(9)\fP    (since
) = default;                                                            C++11)
template< class Alloc
>                                                                       (since
tuple(                                                           \fB(10)\fP   C++11)
std::allocator_arg_t,
const Alloc& a );
template< class Alloc
>
                                                                               (since
tuple(                                                                         C++11)
std::allocator_arg_t,                                                          (until
const Alloc& a,                                                                C++17)

       const
Types&... args );
template< class Alloc
>

/*EXPLICIT*/ tuple(
std::allocator_arg_t,                                                          (since
const Alloc& a,                                                                C++17)

                      \fB(1)\fP
const Types&... args
);
template< class           \fB(2)\fP
Alloc, class...
UTypes >
                                                                                      (since
tuple(                                                                                C++11)
std::allocator_arg_t,                                                                 (until
const Alloc& a,               \fB(3)\fP                                                     C++17)

       UTypes&&...
args );
template< class
Alloc, class...
UTypes >
                                     \fB(4)\fP
/*EXPLICIT*/ tuple(                                                                   (since
std::allocator_arg_t,                                                                 C++17)
const Alloc& a,

                   
UTypes&&... args );
template <class
Alloc, class...
UTypes>                                     \fB(5)\fP
                                                                                             (since
tuple(                                                                                       C++11)
std::allocator_arg_t,                                                                        (until
const Alloc& a,                                                                              C++17)

       const
tuple<UTypes...>&
other );                                           \fB(6)\fP
template <class
Alloc, class...
UTypes>

/*EXPLICIT*/ tuple(
std::allocator_arg_t,                                                                        (since
const Alloc& a,                                                                              C++17)
                                                          \fB(7)\fP
                   
const
tuple<UTypes...>&
other );
template< class
Alloc, class...
UTypes >
                                                                                                    (since
tuple(                                                                                              C++11)
std::allocator_arg_t,                                                                               (until
const Alloc& a,                                                  \fB(11)\fP                               C++17)

     
 tuple<UTypes...>&&
other );
template< class
Alloc, class...
UTypes >

/*EXPLICIT*/ tuple(                                                     \fB(12)\fP                        (since
std::allocator_arg_t,                                                                               C++17)
const Alloc& a,

                   
tuple<UTypes...>&&
other );
template< class
Alloc, class U1,
class U2 >
                                                                               \fB(13)\fP                        (since
tuple(                                                                                                     C++11)
std::allocator_arg_t,                                                                                      (until
const Alloc& a,                                                                                            C++17)

       const pair<U1,
U2>& p );
template< class
Alloc, class U1,
class U2 >

/*EXPLICIT*/ tuple(                                                                                        (since
std::allocator_arg_t,                                                                 \fB(14)\fP                 C++17)
const Alloc& a,

                   
const pair<U1, U2>& p
);
template< class
Alloc, class U1,
class U2 >
                                                                                                                  (since
tuple(                                                                                                            C++11)
std::allocator_arg_t,                                                                        \fB(15)\fP                 (until
const Alloc& a,                                                                                                   C++17)

       pair<U1, U2>&&
p );
template< class
Alloc, class U1,
class U2 >

/*EXPLICIT*/ tuple(                                                                                               (since
std::allocator_arg_t,                                                                               \fB(16)\fP          C++17)
const Alloc& a,

                   
pair<U1, U2>&& p );
template< class Alloc
>
tuple(                                                                                                     \fB(17)\fP   (since
std::allocator_arg_t,                                                                                             C++11)
const Alloc& a, const
tuple& other );
template< class Alloc
>
tuple(                                                                                                     \fB(18)\fP   (since
std::allocator_arg_t,                                                                                             C++11)
const Alloc& a,
tuple&& other );

   Constructs a new tuple.

   1) Default constructor. Value-initializes all elements.

   Requires that std::is_default_constructible<Ti>::value is true for all \fI(until C++17)\fP
   i
   This overload only participates in overload resolution if
   std::is_default_constructible<Ti>::value is true for all i             \fI(since C++17)\fP
   The constructor is explicit if and only if Ti is not implicitly
   default-constructible for at least one i.

   2) Direct constructor. Initializes each element of the tuple with the corresponding
   parameter.
   This overload only participates in overload resolution if sizeof...(Types) >= 1 and
   std::is_copy_constructible<Ti>::value is true for all i.

   This constructor is explicit if and only if std::is_convertible<const  \fI(since C++17)\fP
   Ti&, Ti>::value is false for at least one i.

   3) Converting constructor. Initializes each element of the tuple with the
   corresponding value in std::forward<Utypes>(args).

   Requires that sizeof...(Types) == sizeof...(UTypes)
   This overload only participates in overload resolution if              \fI(until C++17)\fP
   sizeof...(Types) >= 1 and std::is_constructible<Ti, Ui&&>::value is
   true for all i.
   This overload only participates in overload resolution if
   sizeof...(Types) == sizeof...(UTypes) and sizeof...(Types) >= 1 and
   std::is_constructible<Ti, Ui&&>::value is true for all i.              \fI(since C++17)\fP
   The constructor is explicit if and only if std::is_convertible<Ui&&,
   Ti>::value is false for at least one i.

   4) Converting copy-constructor. For all i in sizeof...(UTypes), initializes ith
   element of the tuple with std::get<i>(other).

   Requires that sizeof...(Types) == sizeof...(UTypes)
   This overload only participates in overload resolution if              \fI(until C++17)\fP
   std::is_constructible<Ti, const Ui&>::value is true for all i.
   This overload only participates in overload resolution if

   sizeof...(Types) == sizeof...(UTypes) and
   std::is_constructible_v<Ti, const Ui&> is true for all i and
   sizeof...(Types) != 1 or
                                                                          \fI(since C++17)\fP
   (when Types... expands to T and UTypes... expands to U)
   std::is_convertible_v<const tuple<U>&, T>, std::is_constructible_v<T,
   const tuple<U>&>, and std::is_same_v<T, U> are all false .
   The constructor is explicit if and only if std::is_convertible<const
   Ui&, Ti>::value is false for at least one i.

   5) Converting move-constructor. For all i in sizeof...(UTypes), initializes ith
   element of the tuple with std::forward<Ui>(std::get<i>(other)).

   Requires that sizeof...(Types) == sizeof...(UTypes)
   This overload only participates in overload resolution if              \fI(until C++17)\fP
   std::is_constructible<Ti, Ui&&>::value is true for all i.
   This overload only participates in overload resolution if

   sizeof...(Types) == sizeof...(UTypes) and
   std::is_constructible_v<Ti, Ui&&> is true for all i and
   sizeof...(Types) != 1 or
                                                                          \fI(since C++17)\fP
   (when Types... expands to T and UTypes... expands to U)
   std::is_convertible_v<tuple<U>, T>, std::is_constructible_v<T,
   tuple<U>>, and std::is_same_v<T, U> are all false .
   The constructor is explicit if and only if std::is_convertible<Ui&&,
   Ti>::value is false for at least one i.

   6) Pair copy constructor. Constructs a 2-element tuple with the first element
   constructed from p.first and the second element from p.second

   Requires that sizeof...(Types) == 2
   This overload only participates in overload resolution if              \fI(until C++17)\fP
   std::is_constructible<T0,const U1&>::value and
   std::is_constructible<T1, const U2&>::value are both true
   This overload only participates in overload resolution if
   sizeof...(Types) == 2 and std::is_constructible<T0,const U1&>::value
   and std::is_constructible<T1, const U2&>::value are both true          \fI(since C++17)\fP
   The constructor is explicit if and only if std::is_convertible<const
   U1&, T0>::value or std::is_convertible<const U2&, T1>::value is false

   7) Pair move constructor. Constructs a 2-element tuple with the first element
   constructed from std::forward<U1>(p.first) and the second element from
   std::forward<U2>(p.second)

   Requires that sizeof...(Types) == 2
   This overload only participates in overload resolution if              \fI(until C++17)\fP
   std::is_constructible<T0, U1&&>::value and std::is_constructible<T1,
   U2&&>::value are both true
   This overload only participates in overload resolution if
   sizeof...(Types) == 2 and std::is_constructible<T0, U1&&>::value and
   std::is_constructible<T1, U2&&>::value are both true                   \fI(since C++17)\fP
   The constructor is explicit if and only if std::is_convertible<U1&&,
   T0>::value or std::convertible<U2&&, T1>::value is false

   8) Implicitly-defined copy constructor. Initializes each element of the tuple with
   the corresponding element of other.
   This constructor is constexpr if every operation it performs is constexpr. For the
   empty tuple std::tuple<>, it is constexpr.
   Requires that std::is_copy_constructible<Ti>::value is true for all i.
   9) Implicitly-defined move constructor. Initializes each ith element of the tuple
   with std::forward<Ui>(std::get<i>(other)).
   This constructor is constexpr if every operation it performs is constexpr. For the
   empty tuple std::tuple<>, it is constexpr.
   Requires that std::is_move_constructible<Ti>::value is true for all i.
   10-18) Identical to (1-9) except each element is created by uses-allocator
   construction, that is, the Allocator object a is passed as an additional argument to
   the constructor of each element for which std::uses_allocator<Ui, Alloc>::value is
   true.

.SH Parameters

   args  - values used to initialize each element of the tuple
   other - a tuple of values used to initialize each element of the tuple
   p     - pair of values used to initialize both elements of this 2-tuple
   a     - allocator to use in uses-allocator construction

.SH Notes

   Conditionally-explicit constructors in C++17 make it possible to construct a tuple
   in copy-initialization context using list-initialization syntax:

 std::tuple<int, int> foo_tuple()
 {
   return {1, -1};  // Error until C++17
   return std::make_tuple(1, -1); // Always works
 }

   Note that if some element of the list is not implicitly convertible to the
   corresponding element of the target tuple, the constructors become explicit

 using namespace std::chrono;
 void launch_rocket_at(std::tuple<hours, minutes, seconds>);
  
 launch_rocket_at({hours\fB(1)\fP, minutes\fB(2)\fP, seconds\fB(3)\fP}); // OK
 launch_rocket_at({1, 2, 3}); // Error: int is not implicitly convertible to duration
 launch_rocket_at(std::tuple<hours, minutes, seconds>{1, 2, 3}); // OK

.SH Example

   
// Run this code

 #include <iostream>
 #include <string>
 #include <vector>
 #include <tuple>
 #include <memory>
  
 // helper function to print a tuple of any size
 template<class Tuple, std::size_t N>
 struct TuplePrinter {
     static void print(const Tuple& t)
     {
         TuplePrinter<Tuple, N-1>::print(t);
         std::cout << ", " << std::get<N-1>(t);
     }
 };
  
 template<class Tuple>
 struct TuplePrinter<Tuple, 1>{
     static void print(const Tuple& t)
     {
         std::cout << std::get<0>(t);
     }
 };
  
 template<class... Args>
 void print(const std::tuple<Args...>& t)
 {
     std::cout << "(";
     TuplePrinter<decltype(t), sizeof...(Args)>::print(t);
     std::cout << ")\\n";
 }
 // end helper function
  
 int main()
 {
     std::tuple<int, std::string, double> t1;
     std::cout << "Value-initialized: "; print(t1);
     std::tuple<int, std::string, double> t2(42, "Test", -3.14);
     std::cout << "Initialized with values: "; print(t2);
     std::tuple<char, std::string, int> t3(t2);
     std::cout << "Implicitly converted: "; print(t3);
     std::tuple<int, double> t4(std::make_pair(42, 3.14));
     std::cout << "Constructed from a pair"; print(t4);
  
     // given Allocator my_alloc with a single-argument constructor my_alloc(int)
     // use my_alloc(1) to allocate 10 ints in a vector
     std::vector<int, my_alloc> v(10, 1, my_alloc(1));
     // use my_alloc(2) to allocate 10 ints in a vector in a tuple
     std::tuple<int, std::vector<int, my_alloc>, double> t5(std::allocator_arg,
                                                            my_alloc(2), 42, v,  -3.14);
 }

.SH Output:

 Value-initialized: (0, , 0)
 Initialized with values: (42, Test, -3.14)
 Implicitly converted: (*, Test, -3)
 Constructed from a pair(42, 3.14)

.SH See also

   make_tuple       creates a tuple object of the type defined by the argument types
                    \fI(function template)\fP 
                    creates a tuple of lvalue references or unpacks a tuple into
   tie              individual objects
                    \fI(function template)\fP 
   forward_as_tuple creates a tuple of rvalue references
                    \fI(function template)\fP 
