.TH std::make_tuple 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::make_tuple \- std::make_tuple

.SH Synopsis
   Defined in header <tuple>
   template< class... Types >                                 \fI(since C++11)\fP
   tuple<VTypes...> make_tuple( Types&&... args );            \fI(until C++14)\fP
   template< class... Types >                                 \fI(since C++14)\fP
   constexpr tuple<VTypes...> make_tuple( Types&&... args );

   Creates a tuple object, deducing the target type from the types of arguments.

   For each Ti in Types..., the corresponding type Vi in Vtypes... is
   std::decay<Ti>::type unless application of std::decay results in
   std::reference_wrapper<X> for some type X, in which case the deduced type is X&.

.SH Parameters

   args - zero or more arguments to construct the tuple from

.SH Return value

   A std::tuple object containing the given values, created as if by
   std::tuple<VTypes...>(std::forward<Types>(t)...).

.SH Possible implementation

   template <class T>
   struct unwrap_refwrapper
   {
       using type = T;
   };
    
   template <class T>
   struct unwrap_refwrapper<std::reference_wrapper<T>>
   {
       using type = T&;
   };
    
   template <class T>
   using special_decay_t = typename unwrap_refwrapper<typename std::decay<T>::type>::type;
    
   template <class... Types>
   auto make_tuple(Types&&... args)
   {
       return std::tuple<special_decay_t<Types>...>(std::forward<Types>(args)...);
   }

.SH Example

   
// Run this code

 #include <iostream>
 #include <tuple>
 #include <functional>
  
 std::tuple<int, int> f() // this function returns multiple values
 {
     int x = 5;
     return std::make_tuple(x, 7); // return {x,7}; in C++17
 }
  
 int main()
 {
     // heterogeneous tuple construction
     int n = 1;
     auto t = std::make_tuple(10, "Test", 3.14, std::ref(n), n);
     n = 7;
     std::cout << "The value of t is "  << "("
               << std::get<0>(t) << ", " << std::get<1>(t) << ", "
               << std::get<2>(t) << ", " << std::get<3>(t) << ", "
               << std::get<4>(t) << ")\\n";
  
     // function returning multiple values
     int a, b;
     std::tie(a, b) = f();
     std::cout << a << " " << b << "\\n";
 }

.SH Output:

 The value of t is (10, Test, 3.14, 7, 1)
 5 7

.SH See also

                    creates a tuple of lvalue references or unpacks a tuple into
   tie              individual objects
                    \fI(function template)\fP 
   forward_as_tuple creates a tuple of rvalue references
                    \fI(function template)\fP 
   tuple_cat        creates a tuple by concatenating any number of tuples
                    \fI(function template)\fP 
   apply            calls a function with a tuple of arguments
   \fI(C++17)\fP          \fI(function template)\fP 
