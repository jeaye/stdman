.TH std::cbrt,std::cbrtf,std::cbrtl 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::cbrt,std::cbrtf,std::cbrtl \- std::cbrt,std::cbrtf,std::cbrtl

.SH Synopsis
   Defined in header <cmath>
   float       cbrt ( float num );

   double      cbrt ( double num );                            (until C++23)

   long double cbrt ( long double num );
   /* floating-point-type */                                   (since C++23)
               cbrt ( /* floating-point-type */ num );         (constexpr since C++26)
   float       cbrtf( float num );                     \fB(1)\fP \fB(2)\fP \fI(since C++11)\fP
                                                               (constexpr since C++26)
   long double cbrtl( long double num );                   \fB(3)\fP \fI(since C++11)\fP
                                                               (constexpr since C++26)
   Additional overloads \fI(since C++11)\fP
   Defined in header <cmath>
   template< class Integer >                               (A) (constexpr since C++26)
   double      cbrt ( Integer num );

   1-3) Computes the cube root of num.
   The library provides overloads of std::cbrt for all cv-unqualified floating-point
   types as the type of the parameter.
   (since C++23)

   A) Additional overloads are provided for all integer types, which are  \fI(since C++11)\fP
   treated as double.

.SH Parameters

   num - floating-point or integer value

.SH Return value

   If no errors occur, the cube root of num (\\(\\small{\\sqrt[3]{num} }\\)
   3
   √
   num), is returned.

   If a range error occurs due to underflow, the correct result (after rounding) is
   returned.

.SH Error handling

   Errors are reported as specified in math_errhandling.

   If the implementation supports IEEE floating-point arithmetic (IEC 60559),

     * if the argument is ±0 or ±∞, it is returned, unchanged.
     * if the argument is NaN, NaN is returned.

.SH Notes

   std::cbrt(num) is not equivalent to std::pow(num, 1.0 / 3) because the rational
   number \\(\\small{\\frac1{3} }\\)

   1
   3

   is typically not equal to 1.0 / 3 and std::pow cannot raise a negative base to a
   fractional exponent. Moreover, std::cbrt(num) usually gives more accurate results
   than std::pow(num, 1.0 / 3) (see example).

   The additional overloads are not required to be provided exactly as (A). They only
   need to be sufficient to ensure that for their argument num of integer type,
   std::cbrt(num) has the same effect as std::cbrt(static_cast<double>(num)).

.SH Example


// Run this code

 #include <cmath>
 #include <iomanip>
 #include <iostream>
 #include <limits>

 int main()
 {
     std::cout
         << "Normal use:\\n"
         << "cbrt(729)       = " << std::cbrt(729) << '\\n'
         << "cbrt(-0.125)    = " << std::cbrt(-0.125) << '\\n'
         << "Special values:\\n"
         << "cbrt(-0)        = " << std::cbrt(-0.0) << '\\n'
         << "cbrt(+inf)      = " << std::cbrt(INFINITY) << '\\n'
         << "Accuracy and comparison with `pow`:\\n"
         << std::setprecision(std::numeric_limits<double>::max_digits10)
         << "cbrt(343)       = " << std::cbrt(343) << '\\n'
         << "pow(343,1.0/3)  = " << std::pow(343, 1.0 / 3) << '\\n'
         << "cbrt(-343)      = " << std::cbrt(-343) << '\\n'
         << "pow(-343,1.0/3) = " << std::pow(-343, 1.0 / 3) << '\\n';
 }

.SH Possible output:

 Normal use:
 cbrt(729)       = 9
 cbrt(-0.125)    = -0.5
 Special values:
 cbrt(-0)        = -0
 cbrt(+inf)      = inf
 Accuracy and comparison with `pow`:
 cbrt(343)       = 7
 pow(343,1.0/3)  = 6.9999999999999991
 cbrt(-343)      = -7
 pow(-343,1.0/3) = -nan

.SH See also

   pow
   powf    raises a number to the given power (\\(\\small{x^y}\\)x^y)
   powl    \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   sqrt    computes square root (\\(\\small{\\sqrt{x}}\\)
   sqrtf   √
   sqrtl   x)
   \fI(C++11)\fP \fI(function)\fP
   \fI(C++11)\fP
           computes square root of the sum of the squares of two
           or three
           \fI(since C++17)\fP given numbers (\\(\\scriptsize{\\sqrt{x^2+y^2}}\\)
           √
   hypot   x2
   hypotf  +y2
   hypotl  )
   \fI(C++11)\fP , (\\(\\scriptsize{\\sqrt{x^2+y^2+z^2}}\\)
   \fI(C++11)\fP √
   \fI(C++11)\fP x2
           +y2
           +z2
           )
           \fI(since C++17)\fP
           \fI(function)\fP
   C documentation for
   cbrt
