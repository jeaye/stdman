.TH std::unordered_map::count 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::unordered_map::count \- std::unordered_map::count

.SH Synopsis
   size_type count( const Key& key ) const; \fB(1)\fP \fI(since C++11)\fP
   template< class K >                      \fB(2)\fP \fI(since C++20)\fP
   size_type count( const K& x ) const;

   1) Returns the number of elements with key that compares equal to the specified
   argument key, which is either 0 or 1 since this container does not allow duplicates.
   2) Returns the number of elements with key that compares equivalent to the specified
   argument x. This overload participates in overload resolution only if
   Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type.
   This assumes that such Hash is callable with both K and Key type, and that the
   KeyEqual is transparent, which, together, allows calling this function without
   constructing an instance of Key.

.SH Parameters

   key - key value of the elements to count
   x   - a value of any type that can be transparently compared with a key

.SH Return value

   1) Number of elements with key key, that is either 1 or 0.
   2) Number of elements with key that compares equivalent to x.

.SH Complexity

   Constant on average, worst case linear in the size of the container.

.SH Notes

           Feature-test macro          Value    Std                Feature
                                                      Heterogeneous comparison lookup
   __cpp_lib_generic_unordered_lookup 201811L (C++20) in unordered associative
                                                      containers, overload \fB(2)\fP

.SH Example


// Run this code

 #include <iostream>
 #include <string>
 #include <unordered_map>

 int main()
 {
     std::unordered_map<int, std::string> dict = {
         {1, "one"}, {6, "six"}, {3, "three"}
     };
     dict.insert({4, "four"});
     dict.insert({5, "five"});
     dict.insert({6, "six"});

     std::cout << "dict: { ";
     for (auto const& [key, value] : dict)
         std::cout << '[' << key << "]=" << value << ' ';
     std::cout << "}\\n\\n";

     for (int i{1}; i != 8; ++i)
         std::cout << "dict.count(" << i << ") = " << dict.count(i) << '\\n';
 }

.SH Possible output:

 dict: { [5]=five [4]=four [1]=one [6]=six [3]=three }

 dict.count\fB(1)\fP = 1
 dict.count\fB(2)\fP = 0
 dict.count\fB(3)\fP = 1
 dict.count\fB(4)\fP = 1
 dict.count\fB(5)\fP = 1
 dict.count\fB(6)\fP = 1
 dict.count\fB(7)\fP = 0

.SH See also

   find        finds element with specific key
               \fI(public member function)\fP
   contains    checks if the container contains element with specific key
   (C++20)     \fI(public member function)\fP
   equal_range returns range of elements matching a specific key
               \fI(public member function)\fP
