.TH std::experimental::ranges::all_of,std::experimental::ranges::any_of, 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::all_of,std::experimental::ranges::any_of, \- std::experimental::ranges::all_of,std::experimental::ranges::any_of,

.SH Synopsis

   Defined in header <experimental/ranges/algorithm>
   template< ranges::InputIterator I, ranges::Sentinel<I> S, class Proj =
   ranges::identity,
                                                                              \fB(1)\fP (ranges
      ranges::IndirectUnaryPredicate<ranges::projected<I, Proj>> Pred >           TS)

   bool all_of( I first, S last, Pred pred, Proj proj = Proj{} );
   template< ranges::InputRange Rng, class Proj = ranges::identity,

                                                                                  (ranges
    ranges::IndirectUnaryPredicate<ranges::projected<ranges::iterator_t<Rng>, \fB(2)\fP TS)
   Proj>> Pred >

   bool all_of( Rng&& rng, Pred pred, Proj proj = Proj{} );
   template< ranges::InputIterator I, ranges::Sentinel<I> S, class Proj =
   ranges::identity,
                                                                              \fB(3)\fP (ranges
      ranges::IndirectUnaryPredicate<ranges::projected<I, Proj>> Pred >           TS)

   bool any_of( I first, S last, Pred pred, Proj proj = Proj{} );
   template< ranges::InputRange Rng, class Proj = ranges::identity,

                                                                                  (ranges
    ranges::IndirectUnaryPredicate<ranges::projected<ranges::iterator_t<Rng>, \fB(4)\fP TS)
   Proj>> Pred >

   bool any_of( Rng&& rng, Pred pred, Proj proj = Proj{} );
   template< ranges::InputIterator I, ranges::Sentinel<I> S, class Proj =
   identity,
                                                                              \fB(5)\fP (ranges
      ranges::IndirectUnaryPredicate<ranges::projected<I, Proj>> Pred >           TS)

   bool none_of( I first, S last, Pred pred, Proj proj = Proj{} );
   template< ranges::InputRange Rng, class Proj = ranges::identity,

                                                                                  (ranges
    ranges::IndirectUnaryPredicate<ranges::projected<ranges::iterator_t<Rng>, \fB(6)\fP TS)
   Proj>> Pred >

   bool none_of( Rng&& rng, Pred pred, Proj proj = Proj{} );

   1) Checks if unary predicate pred returns true for all elements in the range [first,
   last).
   3) Checks if unary predicate pred returns true for at least one element in the range
   [first, last).
   5) Checks if unary predicate pred returns true for no elements in the range [first,
   last).
   2,4,6) Same as (1,3,5), but uses rng as the source range, as if by using
   ranges::begin(rng) and ranges::end(rng).

.SH Parameters

   first, last - the range of the elements to examine
   rng         - the range of the elements to examine
   pred        - predicate to apply to the projected elements
   proj        - projection to apply to the elements

.SH Return value

   1-2) true if pred returns true for all elements in the range, false otherwise.
   Returns true if the range is empty.
   3-4) true if pred returns true for at least one element in the range, false
   otherwise. Returns false if the range is empty.
   5-6) true if pred returns true for no elements in the range, false otherwise.
   Returns true if the range is empty.

.SH Complexity

   1-6) At most last - first applications of the predicate and last - first
   applications of the projection.

.SH Possible implementation

.SH First version
template< ranges::InputIterator I, ranges::Sentinel<I> S, class Proj = ranges::identity,
   ranges::IndirectUnaryPredicate<ranges::projected<I, Proj>> Pred >
bool all_of( I first, S last, Pred pred, Proj proj = Proj{} )
{
   return ranges::find_if_not(first, last, std::ref(pred), std::ref(proj)) == last;
}
 
template< ranges::InputRange Rng, class Proj = ranges::identity,
   ranges::IndirectUnaryPredicate<ranges::projected<ranges::iterator_t<Rng>, Proj>> Pred >
bool all_of( Rng&& rng, Pred pred, Proj proj = Proj{} )
{
   return ranges::all_of(ranges::begin(rng), ranges::end(rng), std::ref(pred), std::ref(proj));
}
.SH Second version
template< ranges::InputIterator I, ranges::Sentinel<I> S, class Proj = ranges::identity,
   ranges::IndirectUnaryPredicate<ranges::projected<I, Proj>> Pred >
bool any_of( I first, S last, Pred pred, Proj proj = Proj{} )
{
   return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) != last;
}
 
template< ranges::InputRange Rng, class Proj = ranges::identity,
   ranges::IndirectUnaryPredicate<ranges::projected<ranges::iterator_t<Rng>, Proj>> Pred >
bool any_of( Rng&& rng, Pred pred, Proj proj = Proj{} )
{
   return ranges::any_of(ranges::begin(rng), ranges::end(rng), std::ref(pred), std::ref(proj));
}
                                         Third version
template< ranges::InputIterator I, ranges::Sentinel<I> S, class Proj = identity,
   ranges::IndirectUnaryPredicate<ranges::projected<I, Proj>> Pred >
bool none_of( I first, S last, Pred pred, Proj proj = Proj{} )
{
   return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) == last;
}
 
template< ranges::InputRange Rng, class Proj = ranges::identity,
   ranges::IndirectUnaryPredicate<ranges::projected<ranges::iterator_t<Rng>, Proj>> Pred >
bool none_of( Rng&& rng, Pred pred, Proj proj = Proj{} )
{
   return ranges::none_of(ranges::begin(rng), ranges::end(rng), std::ref(pred), std::ref(proj));
}

.SH Example

   
// Run this code

 #include <vector>
 #include <numeric>
 #include <experimental/ranges/algorithm>
 #include <experimental/ranges/iterator>
 #include <iterator>
 #include <iostream>
 #include <functional>
  
 namespace ranges = std::experimental::ranges;
  
 int main()
 {
     std::vector<int> v(10, 2);
     std::partial_sum(v.cbegin(), v.cend(), v.begin());
     std::cout << "Among the numbers: ";
     ranges::copy(v, ranges::ostream_iterator<int>(std::cout, " "));
     std::cout << '\\n';
  
     if (ranges::all_of(v.cbegin(), v.cend(), [](int i){ return i % 2 == 0; })) {
         std::cout << "All numbers are even\\n";
     }
     if (ranges::none_of(v, std::bind(std::modulus<int>(), std::placeholders::_1, 2))) {
         std::cout << "None of them are odd\\n";
     }
     struct DivisibleBy
     {
         const int d;
         DivisibleBy(int n) : d(n) {}
         bool operator()(int n) const { return n % d == 0; }
     };
  
     if (ranges::any_of(v, DivisibleBy(7))) {
         std::cout << "At least one number is divisible by 7\\n";
     }
 }

.SH Output:

 Among the numbers: 2 4 6 8 10 12 14 16 18 20
 All numbers are even
 None of them are odd
 At least one number is divisible by 7

.SH See also

   all_of
   any_of  checks if a predicate is true for all, any or none of the elements in a
   none_of range
   \fI(C++11)\fP \fI(function template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
