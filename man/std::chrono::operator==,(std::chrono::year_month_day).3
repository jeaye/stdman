.TH std::chrono::operator==,(std::chrono::year_month_day) 3 "2022.03.29" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::chrono::operator==,(std::chrono::year_month_day) \- std::chrono::operator==,(std::chrono::year_month_day)

.SH Synopsis
   Defined in header <chrono>
   constexpr bool operator==( const std::chrono::year_month_day& x, \fB(1)\fP \fI(since C++20)\fP
   const std::chrono::year_month_day& y ) noexcept;
   constexpr std::strong_ordering

   operator<=>( const std::chrono::year_month_day& x,               \fB(2)\fP \fI(since C++20)\fP

   const std::chrono::year_month_day& y ) noexcept;

   Compares the two year_month_day values x and y. This is a lexicographical
   comparison: the year() is compared first, then month(), then day().

   The <, <=, >, >=, and != operators are synthesized from operator<=> and operator==
   respectively.

.SH Return value

   1) x.year() == y.year() && x.month() == y.month() && x.day() == y.day()
   2) If x.year() <=> y.year != 0, x.year() <=> y.year; otherwise if x.month() <=>
   y.month() != 0, x.month() <=> y.month(); otherwise x.day() <=> y.day()

.SH Notes

   If both x and y represent valid dates (x.ok() && y.ok() == true), the result of the
   lexicographical comparison is consistent with the calendar order.

.SH Example


// Run this code

 #include <iostream>
 #include <chrono>

 int main()
 {
     constexpr auto ymd1 {std::chrono::day(1)/7/2021};
     constexpr auto ymd2 {std::chrono::year(2021)/7/1};
     std::cout << std::boolalpha << (ymd1 == ymd2) << '\\n';

     static_assert(ymd1 <= ymd2);
 }

.SH Output:

 true
