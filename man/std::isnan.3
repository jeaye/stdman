.TH std::isnan 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::isnan \- std::isnan

.SH Synopsis
   Defined in header <cmath>
   bool isnan( float arg );        \fB(1)\fP \fI(since C++11)\fP
   bool isnan( double arg );       \fB(2)\fP \fI(since C++11)\fP
   bool isnan( long double arg );  \fB(3)\fP \fI(since C++11)\fP
   bool isnan( IntegralType arg ); \fB(4)\fP \fI(since C++11)\fP

   1-3) Determines if the given floating point number arg is a not-a-number (NaN)
   value.
   4) A set of overloads or a function template accepting the arg argument of any
   integral type. Equivalent to \fB(2)\fP (the argument is cast to double).

.SH Parameters

   arg - floating point value

.SH Return value

   true if arg is a NaN, false otherwise

.SH Notes

   There are many different NaN values with different sign bits and payloads, see
   std::nan and std::numeric_limits::quiet_NaN.

   NaN values never compare equal to themselves or to other NaN values. Copying a NaN
   is not required, by IEEE-754, to preserve its bit representation (sign and payload),
   though most implementation do.

   Another way to test if a floating-point value is NaN is to compare it with itself:
   bool is_nan(double x) { return x != x; }

.SH Example


// Run this code

 #include <iostream>
 #include <cmath>
 #include <cfloat>

 int main()
 {
     std::cout << std::boolalpha
               << "isnan(NaN) = " << std::isnan(NAN) << '\\n'
               << "isnan(Inf) = " << std::isnan(INFINITY) << '\\n'
               << "isnan(0.0) = " << std::isnan(0.0) << '\\n'
               << "isnan(DBL_MIN/2.0) = " << std::isnan(DBL_MIN/2.0) << '\\n'
               << "isnan(0.0 / 0.0)   = " << std::isnan(0.0/0.0) << '\\n'
               << "isnan(Inf - Inf)   = " << std::isnan(INFINITY - INFINITY) << '\\n';
 }

.SH Output:

 isnan(NaN) = true
 isnan(Inf) = false
 isnan(0.0) = false
 isnan(DBL_MIN/2.0) = false
 isnan(0.0 / 0.0)   = true
 isnan(Inf - Inf)   = true

.SH See also

   nan
   nanf
   nanl        not-a-number (NaN)
   \fI(C++11)\fP     \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   fpclassify  categorizes the given floating point value
   \fI(C++11)\fP     \fI(function)\fP
   isfinite    checks if the given number has finite value
   \fI(C++11)\fP     \fI(function)\fP
   isinf       checks if the given number is infinite
   \fI(C++11)\fP     \fI(function)\fP
   isnormal    checks if the given number is normal
   \fI(C++11)\fP     \fI(function)\fP
   isunordered checks if two floating-point values are unordered
   \fI(C++11)\fP     \fI(function)\fP
   C documentation for
   isnan
