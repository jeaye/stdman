.TH std::experimental::ranges::prev 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::prev \- std::experimental::ranges::prev

.SH Synopsis
   Defined in header <experimental/ranges/iterator>
   namespace {
                                                                   (ranges TS)
   constexpr /* unspecified */ prev = /* unspecified */;           (customization point
                                                                   object)
   }
   Call signature
   template< Iterator I >                                      \fB(1)\fP
   constexpr I prev(I i);
   template< Iterator I >                                      \fB(2)\fP
   constexpr I prev(I i, ranges::difference_type_t<I> n);
   template< Iterator I >
   constexpr I prev(I i, ranges::difference_type_t<I> n, I     \fB(3)\fP
   bound);

   Decrements the iterator i n times, or until bound is reached, whichever comes first,
   and returns the decremented iterator.

   1) Equivalent to --i; return i;.
   2) Equivalent to ranges::advance(i, -n); return i;.
   3) Equivalent to ranges::advance(i, -n, bound); return i;.

  Customization point objects

   The name ranges::prev denotes a customization point object, which is a function
   object of a literal Semiregular class type (denoted, for exposition purposes, as
   PrevT). All instances of PrevT are equal. Thus, ranges::prev can be copied freely
   and its copies can be used interchangeably.

   Given a set of types Args..., if std::declval<Args>()... meet the requirements for
   arguments to ranges::prev above, PrevT will satisfy ranges::Invocable<const PrevT,
   Args...>. Otherwise, no function call operator of PrevT participates in overload
   resolution.

   In every translation unit in which ranges::prev is defined, it refers to the same
   instance of the customization point object. (This means that it can be used freely
   in things like inline functions and function templates without violating the
   one-definition rule.)

.SH Return value

   The decremented iterator.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   prev     decrement an iterator
   \fI(C++11)\fP  \fI(function template)\fP
   advance  advances an iterator by given distance
            \fI(function template)\fP
   next     increment an iterator
            \fI(function template)\fP
            returns the distance between an iterator and a sentinel, or between the
   distance beginning and the end of a range
            \fI(function template)\fP
