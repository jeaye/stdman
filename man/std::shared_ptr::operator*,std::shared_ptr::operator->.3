.TH std::shared_ptr::operator*,std::shared_ptr::operator-> 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::shared_ptr::operator*,std::shared_ptr::operator-> \- std::shared_ptr::operator*,std::shared_ptr::operator->

.SH Synopsis
   T& operator*() const noexcept;  \fB(1)\fP \fI(since C++11)\fP
   T* operator->() const noexcept; \fB(2)\fP \fI(since C++11)\fP

   Dereferences the stored pointer. The behavior is undefined if the stored pointer is
   null.

.SH Parameters

   \fI(none)\fP

.SH Return value

   1) The result of dereferencing the stored pointer, i.e., *get()
   2) The stored pointer, i.e., get()

   Remarks

   When T is a (possibly cv-qualified) void, it is unspecified whether function \fB(1)\fP is
   declared.

   When T is an array type, it is unspecified whether these member
   functions are declared, and if they are, what their return type is,    \fI(since C++17)\fP
   except that the declaration (not necessarily the definition) of these
   functions is well-formed.

   If either function is declared despite being unspecified, it is unspecified what its
   return type is, except that the declaration (although not necessarily the
   definition) of the function is guaranteed to be legal. This makes it possible to
   instantiate std::shared_ptr<void>.

.SH Example

   
// Run this code

 #include <iostream>
 #include <memory>
  
 struct Foo
 {
    Foo(int in) : a(in) {}
    void print() const
    {
       std::cout << "a = " << a << '\\n';
    }
    int a;
 };
  
 int main()
 {
    auto ptr = std::make_shared<Foo>(10);
    ptr->print();
    (*ptr).print();
 }

.SH Output:

 a = 10
 a = 10

.SH See also

   get returns the stored pointer
       \fI(public member function)\fP 
