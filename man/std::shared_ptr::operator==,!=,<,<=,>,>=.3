.TH std::shared_ptr::operator==,!=,<,<=,>,>= 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::shared_ptr::operator==,!=,<,<=,>,>= \- std::shared_ptr::operator==,!=,<,<=,>,>=

.SH Synopsis
   Compare two shared_ptr objects
   template < class T, class U >
   bool operator==( const shared_ptr<T>& lhs, const shared_ptr<U>&   \fB(1)\fP  \fI(since C++11)\fP
   rhs ) noexcept;
   template< class T, class U >
   bool operator!=( const shared_ptr<T>& lhs, const shared_ptr<U>&   \fB(2)\fP  \fI(since C++11)\fP
   rhs ) noexcept;
   template< class T, class U >
   bool operator<( const shared_ptr<T>& lhs, const shared_ptr<U>&    \fB(3)\fP  \fI(since C++11)\fP
   rhs ) noexcept;
   template< class T, class U >
   bool operator>( const shared_ptr<T>& lhs, const shared_ptr<U>&    \fB(4)\fP  \fI(since C++11)\fP
   rhs ) noexcept;
   template< class T, class U >
   bool operator<=( const shared_ptr<T>& lhs, const shared_ptr<U>&   \fB(5)\fP  \fI(since C++11)\fP
   rhs ) noexcept;
   template< class T, class U >
   bool operator>=( const shared_ptr<T>& lhs, const shared_ptr<U>&   \fB(6)\fP  \fI(since C++11)\fP
   rhs ) noexcept;
   Compare a shared_ptr with a null pointer
   template< class T >
   bool operator==( const shared_ptr<T>& lhs, std::nullptr_t rhs )   \fB(7)\fP  \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator==( std::nullptr_t lhs, const shared_ptr<T>& rhs )   \fB(8)\fP  \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator!=( const shared_ptr<T>& lhs, std::nullptr_t rhs )   \fB(9)\fP  \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator!=( std::nullptr_t lhs, const shared_ptr<T>& rhs )   \fB(10)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator<( const shared_ptr<T>& lhs, std::nullptr_t rhs )    \fB(11)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator<( std::nullptr_t lhs, const shared_ptr<T>& rhs )    \fB(12)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator>( const shared_ptr<T>& lhs, std::nullptr_t rhs )    \fB(13)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator>( std::nullptr_t lhs, const shared_ptr<T>& rhs )    \fB(14)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator<=( const shared_ptr<T>& lhs, std::nullptr_t rhs )   \fB(15)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator<=( std::nullptr_t lhs, const shared_ptr<T>& rhs )   \fB(16)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator>=( const shared_ptr<T>& lhs, std::nullptr_t rhs )   \fB(17)\fP \fI(since C++11)\fP
   noexcept;
   template< class T >
   bool operator>=( std::nullptr_t lhs, const shared_ptr<T>& rhs )   \fB(18)\fP \fI(since C++11)\fP
   noexcept;

   Compares two shared_ptr<T> objects or compares shared_ptr<T> with a null pointer.

   Note that the comparison operators for shared_ptr simply compare pointer values; the
   actual objects pointed to are not compared. Having operator< defined for shared_ptr
   allows shared_ptrs to be used as keys in associative containers, like std::map and
   std::set.

.SH Parameters

   lhs - the left-hand shared_ptr to compare
   rhs - the right-hand shared_ptr to compare

.SH Return value

   1) lhs.get() == rhs.get()
   2) !(lhs == rhs)
   3) std::less<V>()(lhs.get(), rhs.get()), where V is the composite pointer type of
   std::shared_ptr<T>::element_type* and std::shared_ptr<U>::element_type*
   4) rhs < lhs
   5) !(rhs < lhs)
   6) !(lhs < rhs)
   7) !lhs
   8) !rhs
   9) (bool)lhs
   10) (bool)rhs
   11) std::less<std::shared_ptr<T>::element_type*>()(lhs.get(), nullptr)
   12) std::less<std::shared_ptr<T>::element_type*>()(nullptr, rhs.get())
   13) nullptr < lhs
   14) rhs < nullptr
   15) !(nullptr < lhs)
   16) !(rhs < nullptr)
   17) !(lhs < nullptr)
   18) !(nullptr < rhs)

.SH Notes

   In all cases, it is the stored pointer (the one returned by get()) that is compared,
   rather than the managed pointer (the one passed to the deleter when use_count goes
   to zero). The two pointers may differ in a shared_ptr created using the aliasing
   constructor.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   get returns the stored pointer
       \fI(public member function)\fP 

.SH Category:

     * Todo no example
