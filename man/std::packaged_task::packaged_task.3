.TH std::packaged_task::packaged_task 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::packaged_task::packaged_task \- std::packaged_task::packaged_task

.SH Synopsis
   packaged_task()                                                    \fB(1)\fP \fI(since C++11)\fP
   template <class F>                                                 \fB(2)\fP \fI(since C++11)\fP
   explicit packaged_task( F&& f )
   template <class F, class Allocator>
   explicit packaged_task( std::allocator_arg_t, const Allocator& a,  \fB(3)\fP \fI(since C++11)\fP
   F&& f )
   packaged_task( packaged_task& ) = delete                           \fB(4)\fP \fI(since C++11)\fP
                                                                          \fI(until C++14)\fP
   packaged_task( const packaged_task& ) = delete                     \fB(4)\fP \fI(since C++14)\fP
   packaged_task( packaged_task&& rhs )                               \fB(5)\fP \fI(since C++11)\fP

   Constructs a new std::packaged_task object.

   1) Constructs a std::packaged_task object with no task and no shared state.
   2) Constructs a std::packaged_task object with a shared state and a copy of the
   task, initialized with std::forward<F>(f). This constructor does not participate in
   overload resolution if std::decay<F>::type is the same type as
   std::packaged_task<R(ArgTypes...)>.
   3) Constructs a std::packaged_task object with a shared state and a copy of the
   task, initialized with std::forward<F>(f). Uses the provided allocator to allocate
   memory necessary to store the task. This constructor does not participate in
   overload resolution if std::decay<F>::type is the same type as
   std::packaged_task<R(ArgTypes...)>.
   4) The copy constructor is deleted, std::packaged_task is move-only.
   5) Constructs a std::packaged_task with the shared state and task formerly owned by
   rhs, leaving rhs with no shared state and a moved-from task.

.SH Parameters

   f   - the callable target \fI(function, member function, lambda-expression, functor) to\fP
         execute
   a   - the allocator to use when storing the task
   rhs - the std::packaged_task to move from

.SH Exceptions

   1)
   noexcept specification:  
   noexcept
     
   2-3) Any exceptions thrown by copy/move constructor of f and possiblly
   std::bad_alloc if the allocation fails.
   4) \fI(none)\fP
   5)
   noexcept specification:  
   noexcept
     

.SH Example

   
// Run this code

 #include <future>
 #include <iostream>
 #include <thread>
  
 int fib(int n)
 {
     if (n < 3) return 1;
     else return fib(n-1) + fib(n-2);
 }
  
 int main()
 {
     std::packaged_task<int(int)> fib_task(&fib);
  
     std::cout << "starting task\\n";
     auto result = fib_task.get_future();
     std::thread t(std::move(fib_task), 40);
  
     std::cout << "waiting for task to finish...\\n";
     std::cout << result.get() << '\\n';
  
     std::cout << "task complete\\n";
     t.join();
 }

.SH Output:

 starting task
 waiting for task to finish...
 102334155
 task complete
