.TH std::async 3 "2017.04.02" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::async \- std::async

.SH Synopsis
Defined in header <future>
template< class Function, class... Args>                                             (since
                                                                                     C++11)
std::future<typename std::result_of<Function(Args...)>::type>                        (until
                                                                                     C++14)
    async( Function&& f, Args&&... args );
template< class Function, class... Args>
                                                                                     (since
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>         C++14)

    async( Function&& f, Args&&... args );                                   \fB(1)\fP
template< class Function, class... Args >                                                   (since
                                                                                            C++11)
std::future<typename std::result_of<Function(Args...)>::type>                               (until
                                                                                            C++14)
    async( std::launch policy, Function&& f, Args&&... args );                   \fB(2)\fP
template< class Function, class... Args >
                                                                                            (since
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>                C++14)

    async( std::launch policy, Function&& f, Args&&... args );

   The template function async runs the function f asynchronously (potentially in a
   separate thread which may be part of a thread pool) and returns a std::future that
   will eventually hold the result of that function call.

   1) Behaves the same as async(std::launch::async | std::launch::deferred, f,
   args...). In other words, f may be executed in another thread or it may be run
   synchronously when the resulting std::future is queried for a value.
   2) Calls a function f with arguments args according to a specific launch policy
   policy:

     * If the async flag is set (i.e. policy & std::launch::async != 0), then async
       executes the function f on a new thread of execution (with all thread-locals
       initialized) as if spawned by std::thread(f, args...), except that if the
       function f returns a value or throws an exception, it is stored in the shared
       state accessible through the std::future that async returns to the caller.
     * If the deferred flag is set (i.e. policy & std::launch::deferred != 0), then
       async converts args... the same way as by std::thread constructor, but does not
       spawn a new thread of execution. Instead, lazy evaluation is performed: the
       first call to a non-timed wait function on the std::future that async returned
       to the caller will cause f(args...) to be executed in the current thread (which
       does not have to be the thread that originally called std::async). The result or
       exception is placed in the shared state associated with the future and only then
       it is made ready. All further accesses to the same std::future will return the
       result immediately.
     * If both the std::launch::async and std::launch::deferred flags are set in
       policy, it is up to the implementation whether to perform asynchronous execution
       or lazy evaluation.

     * If neither std::launch::async nor std::launch::deferred, nor any
       implementation-defined policy flag is set in policy, the behavior  \fI(since C++14)\fP
       is undefined.

   In any case, the call to std::async synchronizes-with (as defined in
   std::memory_order) the call to f, and the completion of f is sequenced-before making
   the shared state ready. If the async policy is chosen, the associated thread
   completion synchronizes-with the successful return from the first function that is
   waiting on the shared state, or with the return of the last function that releases
   the shared state, whichever comes first.

.SH Parameters

   f       - Callable object to call
   args... - parameters to pass to f
             bitmask value, where individual bits control the allowed methods of
             execution
   policy  -
             Bit                   Explanation
             std::launch::async    enable asynchronous evaluation
             std::launch::deferred enable lazy evaluation
.SH Type requirements
   -
   Function, Args must meet the requirements of MoveConstructible.

.SH Return value

   std::future referring to the shared state created by this call to std::async.

.SH Exceptions

   Throws std::system_error with error condition
   std::errc::resource_unavailable_try_again if the launch policy equals
   std::launch::async and the implementation is unable to start a new thread (if the
   policy is async|deferred or has additional bits set, it will fall back to deferred
   or the implementation-defined policies in this case), or std::bad_alloc if memory
   for the internal data structures could not be allocated.

.SH Notes

   The implementation may extend the behavior of the first overload of std::async by
   enabling additional (implementation-defined) bits in the default launch policy.

   Examples of implementation-defined launch policies are the sync policy (execute
   immediately, within the async call) and the task policy (similar to async, but
   thread-locals are not cleared)

   If the std::future obtained from std::async is not moved from or bound to a
   reference, the destructor of the std::future will block at the end of the full
   expression until the asynchronous operation completes, essentially making code such
   as the following synchronous:

 std::async(std::launch::async, []{ f(); }); // temporary's dtor waits for f()
 std::async(std::launch::async, []{ g(); }); // does not start until f() completes

   (note that the destructors of std::futures obtained by means other than a call to
   std::async never block)

.SH Example

   
// Run this code

 #include <iostream>
 #include <vector>
 #include <algorithm>
 #include <numeric>
 #include <future>
  
 template <typename RAIter>
 int parallel_sum(RAIter beg, RAIter end)
 {
     auto len = end - beg;
     if(len < 1000)
         return std::accumulate(beg, end, 0);
  
     RAIter mid = beg + len/2;
     auto handle = std::async(std::launch::async,
                              parallel_sum<RAIter>, mid, end);
     int sum = parallel_sum(beg, mid);
     return sum + handle.get();
 }
  
 int main()
 {
     std::vector<int> v(10000, 1);
     std::cout << "The sum is " << parallel_sum(v.begin(), v.end()) << '\\n';
 }

.SH Output:

 The sum is 10000
