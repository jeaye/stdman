.TH std::complex::complex 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::complex::complex \- std::complex::complex

.SH Synopsis
Primary template
(std::complex<T>)
complex( const T& re         (until
= T(), const T& im =         C++14)
T() );
constexpr complex(           (since
const T& re = T(),           C++14)
const T& im = T() );
complex( const                      (until
complex& other );                   C++14)
constexpr complex(                  (since
const complex& other                C++14)
);                                  (until
                                    C++23)
constexpr complex(                  (since
const complex& other                C++23)
) = default;
template< class X >                        (until
complex( const                             C++14)
complex<X>& other );
template< class X >                        (since
constexpr complex(                         C++14)
const complex<X>&                          (until
other );                                   C++23)
template< class X >
constexpr
explicit(/* see                            (since
below */) complex(                         C++23)
const complex<X>&
other );
Standard explicit
specialization
std::complex<float>
(until C++23)
complex( float re =                               (until
0.0f, float im =                                  C++11)
0.0f );
constexpr complex(                                (since
float re = 0.0f,                                  C++11)
float im = 0.0f );
constexpr complex(
const                                      \fB(2)\fP    (since
complex<float>&                                   C++20)
other ) = default;
explicit complex(
const
complex<double>&                                         (until
other );                                                 C++11)
explicit complex(
const complex<long
double>& other );
constexpr explicit
complex( const
complex<double>&
other );                                                 (since
constexpr explicit                                       C++11)
complex( const
complex<long
double>& other );
Standard explicit    \fB(1)\fP
specialization
std::complex<double>
(until C++23)            \fB(2)\fP
complex( double re =                                            (until
0.0, double im = 0.0                                            C++11)
);
constexpr complex(           \fB(3)\fP                                (since
double re = 0.0,                                                C++11)
double im = 0.0 );
constexpr complex(
const                                                    \fB(2)\fP    (since
complex<double>&                                                C++20)
other ) = default;
complex( const
complex<float>&
other );                            \fB(1)\fP                                (until
explicit complex(                                                      C++11)
const complex<long
double>& other );
constexpr complex(
const                                      \fB(3)\fP
complex<float>&
other );                                                               (since
constexpr explicit                                                     C++11)
complex( const
complex<long
double>& other );
Standard explicit
specialization
std::complex<long                                 \fB(1)\fP
double> (until
C++23)
complex( long double                                                          (until
re = 0.0L, long                                                               C++11)
double im = 0.0L );                                      \fB(3)\fP
constexpr complex(
long double re =                                                              (since
0.0L, long double im                                                          C++11)
= 0.0L );
constexpr complex(
const complex<long                                                     \fB(2)\fP    (since
double>& other ) =                                                            C++20)
default;
complex( const
complex<float>&                                                 \fB(1)\fP
other );                                                                             (until
complex( const                                                                       C++11)
complex<double>&
other );
constexpr complex(                                                     \fB(3)\fP
const
complex<float>&
other );                                                                             (since
constexpr complex(                                                                   C++11)
const
complex<double>&
other );

   Constructs the std::complex object.
   The standard explicit specializations (std::complex<float>, std::complex<double> and
   std::complex<long double>) have different constructor declarations from the main
   template.
   (until C++23)

   1) Constructs the complex number from real part re and imaginary part im.
   2) Copy constructor. Constructs the object with the copy of the contents of other.
   The copy constructors are implicitly declared in the standard explicit
   specializations.
   \fI(until C++20)\fP
   3) Converting constructor. Constructs the object from a complex number of a
   different type.

   The main template provides a converting constructor template, while
   each standard explicit specialization provides two non-template
   constructors for the two other standard explicit specializations.
                                                                          (until C++23)
   The non-template constructors are converting constructors (i.e.
   non-explicit) if and only if the conversions of the real and imaginary
   parts are not narrowing.
   For the main template, the expression inside explicit evaluates to
   false if and only if the floating-point conversion rank of T is        (since C++23)
   greater than or equal to the floating-point conversion rank of X.

.SH Parameters

   re    - the real part
   im    - the imaginary part
   other - another complex number to use as source

.SH Notes

   Since C++23, the copy constructor is required to be trivial in order to satisfy the
   TriviallyCopyable requirement, but implementations generally make it trivial in all
   modes.

.SH See also

   operator=    assigns the contents
                \fI(public member function)\fP
   operator""if
   operator""i  a std::complex literal representing purely imaginary number
   operator""il \fI(function)\fP
   \fI(C++14)\fP
   C documentation for
   CMPLX
