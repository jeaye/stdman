.TH std::in_place,std::in_place_type,std::in_place_index,std::in_place_t, 3 "2019.08.27" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::in_place,std::in_place_type,std::in_place_index,std::in_place_t, \- std::in_place,std::in_place_type,std::in_place_index,std::in_place_t,

.SH Synopsis

   Defined in header <utility>
   struct in_place_t {

   explicit in_place_t() = default;                        \fI(since C++17)\fP
   };

   inline constexpr in_place_t in_place{};
   template <class T> struct in_place_type_t {

   explicit in_place_type_t() = default;
   };                                                      \fI(since C++17)\fP
   template <class T>

   inline constexpr in_place_type_t<T> in_place_type{};
   template <std::size_t I> struct in_place_index_t {

   explicit in_place_index_t() = default;
   };                                                      \fI(since C++17)\fP
   template <std::size_t I>

   inline constexpr in_place_index_t<I> in_place_index{};

   std::in_place, std::in_place_type, and std::in_place_index are disambiguation tags
   that can be passed to the constructors of std::optional, std::variant, and std::any
   to indicate that the contained object should be constructed in-place, and (for the
   latter two) the type of the object to be constructed.

   The corresponding type/type templates std::in_place_t, std::in_place_type_t and
   std::in_place_index_t can be used in the constructor's parameter list to match the
   intended tag.

.SH See also

   optional a wrapper that may or may not hold an object
   \fI(C++17)\fP  \fI(class template)\fP
   variant  a type-safe discriminated union
   \fI(C++17)\fP  \fI(class template)\fP
   any      Objects that hold instances of any CopyConstructible type.
   \fI(C++17)\fP  \fI(class)\fP
