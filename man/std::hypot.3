.TH std::hypot 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::hypot \- std::hypot

.SH Synopsis
   Defined in header <cmath>
   float       hypot( float x, float y );                            \fB(1)\fP \fI(since C++11)\fP
   double      hypot( double x, double y );                          \fB(2)\fP \fI(since C++11)\fP
   long double hypot( long double x, long double y );                \fB(3)\fP \fI(since C++11)\fP
   Promoted    hypot( Arithmetic1 x, Arithmetic2 y );                \fB(4)\fP \fI(since C++11)\fP
   float       hypot( float x, float y, float z );                   \fB(5)\fP \fI(since C++17)\fP
   double      hypot( double x, double y, double z );                \fB(6)\fP \fI(since C++17)\fP
   long double hypot( long double x, long double y, long double z ); \fB(7)\fP \fI(since C++17)\fP
   Promoted    hypot( Arithmetic1 x, Arithmetic2 y, Arithmetic3 z ); \fB(8)\fP \fI(since C++17)\fP

   1-3) Computes the square root of the sum of the squares of x and y, without undue
   overflow or underflow at intermediate stages of the computation.
   4) A set of overloads or a function template for all combinations of arguments of
   arithmetic type not covered by (1-3). If any argument has integral type, it is cast
   to double. If any other argument is long double, then the return type is long
   double, otherwise it is double.
   5-7) Computes the square root of the sum of the squares of x, y, and z, without
   undue overflow or underflow at intermediate stages of the computation.
   8) A set of overloads or a function template for all combinations of arguments of
   arithmetic type not covered by (5-7). If any argument has integral type, it is cast
   to double. If any other argument is long double, then the return type is long
   double, otherwise it is double.

   The value computed by the two-argument version of this function is the length of the
   hypotenuse of a right-angled triangle with sides of length x and y, or the distance
   of the point (x,y) from the origin (0,0), or the magnitude of a complex number x+iy

   The value computed by the three-argument version of this function is the distance of
   the point (x,y,z) from the origin (0,0,0).

.SH Parameters

   x, y, z - values of floating-point or integral types

.SH Return value

   1-4) If no errors occur, the hypotenuse of a right-angled triangle,
   √
   x2
   +y2
   , is returned.
   5-8) If no errors occur, the distance from origin in 3D space,
   √
   x2
   +y2
   +z2
   , is returned.

   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is
   returned.

   If a range error due to underflow occurs, the correct result (after rounding) is
   returned.

.SH Error handling

   Errors are reported as specified in math_errhandling

   If the implementation supports IEEE floating-point arithmetic (IEC 60559),

     * hypot(x, y), hypot(y, x), and hypot(x, -y) are equivalent
     * if one of the arguments is ±0, hypot(x,y) is equivalent to fabs called with the
       non-zero argument
     * if one of the arguments is ±∞, hypot(x,y) returns +∞ even if the other argument
       is NaN
     * otherwise, if any of the arguments is NaN, NaN is returned

.SH Notes

   Implementations usually guarantee precision of less than 1 ulp (units in the last
   place): GNU, BSD, Open64

   std::hypot(x, y) is equivalent to std::abs(std::complex<double>(x,y))

   POSIX specifies that underflow may only occur when both arguments are subnormal and
   the correct result is also subnormal (this forbids naive implementations)

   Distance between two points (x1,y1,z1) and (x2,y2,z2)on 3D space can be calculated
   as std::hypot(x2-x1, y2-y1, z2-z1)

.SH Example

   
// Run this code

 #include <iostream>
 #include <cmath>
 #include <cerrno>
 #include <cfenv>
 #include <cfloat>
 #include <cstring>
  
 #pragma STDC FENV_ACCESS ON
 int main()
 {
     // typical usage
     std::cout << "(1,1) cartesian is (" << std::hypot(1,1)
               << ',' << std::atan2(1,1) << ") polar\\n";
     // special values
     std::cout << "hypot(NAN,INFINITY) = " << std::hypot(NAN,INFINITY) << '\\n';
     // error handling
     errno = 0; std::feclearexcept(FE_ALL_EXCEPT);
     std::cout << "hypot(DBL_MAX,DBL_MAX) = " << std::hypot(DBL_MAX,DBL_MAX) << '\\n';
     if(errno == ERANGE)
         std::cout << "    errno = ERANGE " << std::strerror(errno) << '\\n';
     if(fetestexcept(FE_OVERFLOW))
         std::cout << "    FE_OVERFLOW raised\\n";
 }

.SH Output:

 (1,1) cartesian is (1.41421,0.785398) polar
 hypot(NAN,INFINITY) = inf
 hypot(DBL_MAX,DBL_MAX) = inf
     errno = ERANGE Numerical result out of range
     FE_OVERFLOW raised

.SH See also

   pow               raises a number to the given power (x^y)
                     \fI(function)\fP 
                     computes square root (
   sqrt              √
                     x)
                     \fI(function)\fP 
                     computes cubic root (
   cbrt              3
   \fI(C++11)\fP           √
                     x)
                     \fI(function)\fP 
   abs(std::complex) returns the magnitude of a complex number
                     \fI(function template)\fP 
   C documentation for
   hypot
