.TH std::is_swappable_with,std::is_swappable,std::is_nothrow_swappable_with, 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::is_swappable_with,std::is_swappable,std::is_nothrow_swappable_with, \- std::is_swappable_with,std::is_swappable,std::is_nothrow_swappable_with,

.SH Synopsis

   Defined in header <type_traits>
   template< class T, class U >      \fB(1)\fP \fI(since C++17)\fP
   struct is_swappable_with;
   template< class T >               \fB(2)\fP \fI(since C++17)\fP
   struct is_swappable;
   template< class T, class U >      \fB(3)\fP \fI(since C++17)\fP
   struct is_nothrow_swappable_with;
   template< class T >               \fB(4)\fP \fI(since C++17)\fP
   struct is_nothrow_swappable;

   1) If the expressions swap(std::declval<T>(), std::declval<U>()) and
   swap(std::declval<U>(), std::declval<T>()) are both well-formed in unevaluated
   context after using std::swap; (see Swappable), provides the member constant value
   equal true. Otherwise, value is false.
   Access checks are performed as if from a context unrelated to either type.
   3) Same as \fB(1)\fP, but evaluations of both expressions from (1) are known not to throw
   exceptions.

                                The value of the member constant value
    Type trait            T is a referenceable type            T is not a referenceable
                                                                        type
   \fB(2)\fP          std::is_swappable_with<T&, T&>::value         false
   \fB(4)\fP          std::is_nothrow_swappable_with<T&, T&>::value

   If T or U is not a complete type, (possibly cv-qualified) void, or an array of
   unknown bound, the behavior is undefined.

   If an instantiation of a template above depends, directly or indirectly, on an
   incomplete type, and that instantiation could yield a different result if that type
   were hypothetically completed, the behavior is undefined.

   If the program adds specializations for any of the templates described on this page,
   the behavior is undefined.

.SH Member constants

   value    true if T is swappable with U, false otherwise
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator bool converts the object to bool, returns value
                 \fI(public member function)\fP
   operator()    returns value
   \fI(C++14)\fP       \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type bool
   type       std::integral_constant<bool, value>

.SH Notes

   This trait does not check anything outside the immediate context of the swap
   expressions: if the use of T or U would trigger template specializations, generation
   of implicitly-defined special member functions etc, and those have errors, the
   actual swap may not compile even if std::is_swappable_with<T, U>::value compiles and
   evaluates to true.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   swap                         swaps the values of two objects
                                \fI(function template)\fP
   is_move_assignable
   is_trivially_move_assignable
   is_nothrow_move_assignable   checks if a type has a move assignment operator
   \fI(C++11)\fP                      \fI(class template)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   swappable                    specifies that a type can be swapped or that two types
   swappable_with               can be swapped with each other
   (C++20)                      (concept)

.SH Category:
     * Todo no example
