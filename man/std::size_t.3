.TH std::size_t 3 "2019.08.27" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::size_t \- std::size_t

.SH Synopsis
   Defined in header <cstddef>
   Defined in header <cstdio>
   Defined in header <cstdlib>
   Defined in header <cstring>
   Defined in header <ctime>
   Defined in header <cwchar>
   typedef /*implementation-defined*/ size_t;

   std::size_t is the unsigned integer type of the result of the sizeof operator
   as well as the sizeof... operator and the alignof operator
   \fI(since C++11)\fP.

.SH Notes

   std::size_t can store the maximum size of a theoretically possible object of any
   type (including array).
   A type whose size cannot be represented by std::size_t is ill-formed
   \fI(since C++14)\fP On many platforms (an exception is systems with segmented addressing)
   std::size_t can safely store the value of any non-member pointer, in which case it
   is synonymous with std::uintptr_t.

   std::size_t is commonly used for array indexing and loop counting. Programs that use
   other types, such as unsigned int, for array indexing may fail on, e.g. 64-bit
   systems when the index exceeds UINT_MAX or if it relies on 32-bit modular
   arithmetic.

   When indexing C++ containers, such as std::string, std::vector, etc, the appropriate
   type is the member typedef size_type provided by such containers. It is usually
   defined as a synonym for std::size_t.

.SH Example

   
// Run this code

 #include <cstddef>
 #include <iostream>
 #include <array>

 int main()
 {
     std::array<std::size_t,10> a;
     for (std::size_t i = 0; i != a.size(); ++i)
         a[i] = i;
     for (std::size_t i = a.size()-1; i < a.size(); --i)
         std::cout << a[i] << " ";
 }

.SH Output:

 9 8 7 6 5 4 3 2 1 0

.SH See also

   ptrdiff_t signed integer type returned when subtracting two pointers
             \fI(typedef)\fP
             byte offset from the beginning of a standard-layout type to specified
   offsetof  member
             \fI(function macro)\fP
