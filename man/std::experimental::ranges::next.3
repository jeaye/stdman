.TH std::experimental::ranges::next 3 "2022.03.29" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::ranges::next \- std::experimental::ranges::next

.SH Synopsis
   Defined in header <experimental/ranges/iterator>
   namespace {
                                                                   (ranges TS)
   constexpr /* unspecified */ next = /* unspecified */;           (customization point
                                                                   object)
   }
   Call signature
   template< Iterator I >                                      \fB(1)\fP
   constexpr I next(I i);
   template< Iterator I >                                      \fB(2)\fP
   constexpr I next(I i, ranges::difference_type_t<I> n);
   template< Iterator I, Sentinel<I> S >                       \fB(3)\fP
   constexpr I next(I i, S bound);
   template< Iterator I, Sentinel<I> S >
   constexpr I next(I i, ranges::difference_type_t<I> n, S     \fB(4)\fP
   bound);

   Advances the iterator i n times, or until bound is reached, whichever comes first,
   and returns the advanced iterator.

   1) Equivalent to ++i; return i;.
   2) Equivalent to ranges::advance(i, n); return i;.
   3) Equivalent to ranges::advance(i, bound); return i;.
   4) Equivalent to ranges::advance(i, n, bound); return i;.

  Customization point objects

   The name ranges::next denotes a customization point object, which is a function
   object of a literal Semiregular class type (denoted, for exposition purposes, as
   NextT). All instances of NextT are equal. Thus, ranges::next can be copied freely
   and its copies can be used interchangeably.

   Given a set of types Args..., if std::declval<Args>()... meet the requirements for
   arguments to ranges::next above, NextT will satisfy ranges::Invocable<const NextT,
   Args...>. Otherwise, no function call operator of NextT participates in overload
   resolution.

   In every translation unit in which ranges::next is defined, it refers to the same
   instance of the customization point object. (This means that it can be used freely
   in things like inline functions and function templates without violating the
   one-definition rule.)

.SH Return value

   The advanced iterator.

.SH Notes

   Even though omitting n for overload \fB(2)\fP behaves as if n is 1, omitting n for
   overload \fB(4)\fP effectively behaves as if n is infinity (always advance to bound).

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   next     increment an iterator
   \fI(C++11)\fP  \fI(function template)\fP
   advance  advances an iterator by given distance
            \fI(function template)\fP
   prev     decrement an iterator
            \fI(function template)\fP
            returns the distance between an iterator and a sentinel, or between the
   distance beginning and the end of a range
            \fI(function template)\fP
