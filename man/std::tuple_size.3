.TH std::tuple_size 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::tuple_size \- std::tuple_size

.SH Synopsis
   Defined in header <tuple>
   template< class T >                                        \fB(1)\fP \fI(since C++11)\fP
   class tuple_size; /*undefined*/
   template< class... Types >

   class tuple_size< std::tuple<Types...> >                   \fB(2)\fP \fI(since C++11)\fP

    : public std::integral_constant<std::size_t,
   sizeof...(Types)> { };
   Defined in header <tuple>
   Defined in header <array>                                      \fI(since C++17)\fP
   Defined in header <utility>                                    \fI(since C++17)\fP
   Defined in header <ranges>                                     \fI(since C++20)\fP
   template< class T >

   class tuple_size<const T>                                  \fB(3)\fP \fI(since C++11)\fP

    : public std::integral_constant<std::size_t,
   tuple_size<T>::value> { };
   template< class T >

   class tuple_size< volatile T >                             \fB(4)\fP \fI(since C++11)\fP
                                                                  (deprecated in C++20)
    : public std::integral_constant<std::size_t,
   tuple_size<T>::value> { };
   template< class T >

   class tuple_size< const volatile T >                       \fB(5)\fP \fI(since C++11)\fP
                                                                  (deprecated in C++20)
    : public std::integral_constant<std::size_t,
   tuple_size<T>::value> { };

   Provides access to the number of elements in a tuple as a compile-time constant
   expression.

   In addition to being available via inclusion of the <tuple> header, the templates
   (3-5) are available when either of the headers <array> or <utility> are included.

   All specializations of std::tuple_size satisfy UnaryTypeTrait with base
   characteristic std::integral_constant<std::size_t, N> for some N.

The cv-T templates (3-5) are SFINAE-friendly: if std::tuple_size<T>::value is ill-formed
when treated as an unevaluated operand, (3-5) do not provide the member value. Access
checking is performed as if in a context unrelated to tuple_size and T. Only the
validity of the immediate context of the expression is considered. This allows           (since
                                                                                         C++17)
#include <utility>
struct X { int a, b; };
const auto [x, y] = X(); // decomposition declaration first attempts tuple_size<const X>
                         // which attempts to use tuple_size<X>::value, and that's OK

.SH Member constants

   value    sizeof...(Types)
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator std::size_t converts the object to std::size_t, returns value
                        \fI(public member function)\fP
   operator()           returns value
   \fI(C++14)\fP              \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type std::size_t
   type       std::integral_constant<std::size_t, value>

.SH Example


// Run this code

 #include <iostream>
 #include <tuple>

 template <class T>
 void test(T t)
 {
     int a[std::tuple_size<T>::value]; // can be used at compile time

     std::cout << std::tuple_size<T>::value << '\\n'; // or at run time
 }

 int main()
 {
     test(std::make_tuple(1, 2, 3.14));
 }

.SH Output:

 3

.SH See also

   std::tuple_size<std::array> obtains the size of an array
                               \fI(class template specialization)\fP
   std::tuple_size<std::pair>  obtains the size of a pair
   \fI(C++11)\fP                     \fI(class template specialization)\fP
   std::get(std::tuple)        tuple accesses specified element
                               \fI(function template)\fP
   tuple_element               obtains the type of the specified element
                               \fI(class template specialization)\fP
