.TH std::to_address 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::to_address \- std::to_address

.SH Synopsis
   Defined in header <memory>
   template< class Ptr >                   \fB(1)\fP (since C++20)
   auto to_address(const Ptr& p) noexcept;
   template< class T >                     \fB(2)\fP (since C++20)
   constexpr T* to_address(T* p) noexcept;

   Obtain the address represented by p without forming a reference to the pointee.

   1) Fancy pointer overload: If the expression std::pointer_traits<Ptr>::to_address(p)
   is well-formed, returns the result of that expression. Otherwise, returns
   std::to_address(p.operator->()).
   2) Raw pointer overload: If T is a function type, the program is ill-formed.
   Otherwise, returns p unmodified.

.SH Parameters

   p - fancy or raw pointer

.SH Return value

   Raw pointer that represents the same address as p does.

.SH Notes

   std::to_address can be used even when p does not reference storage that has an
   object constructed in it, in which case std::addressof(*p) cannot be used because
   there's no valid object for the parameter of std::addressof to bind to.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   pointer_traits   provides information about pointer-like types
   \fI(C++11)\fP          \fI(class template)\fP 
   to_address       obtains a raw pointer from a fancy pointer (inverse of pointer_to)
   \fB[static]\fP (C++20) \fI(public static member function of std::pointer_traits)\fP 

.SH Category:

     * Todo no example
