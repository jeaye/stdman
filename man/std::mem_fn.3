.TH std::mem_fn 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::mem_fn \- std::mem_fn

.SH Synopsis
   Defined in header <functional>
   template< class M, class T >                                  \fB(1)\fP \fI(since C++11)\fP
   /*unspecified*/ mem_fn(M T::* pm);
   template< class R, class T, class... Args >

   /*unspecified*/ mem_fn(R (T::* pm)(Args...));
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) const);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) volatile);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) const volatile);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) &);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) const &);
   template< class R, class T, class... Args >                   \fB(2)\fP \fI(since C++11)\fP
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) volatile &);          (removed in C++14)
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) const volatile
   &);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) &&);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) const &&);
   template< class R, class T, class... Args >
   /*unspecified*/ mem_fn(R (T::* pm)(Args...) volatile &&);
   template< class R, class T, class... Args >

   /*unspecified*/ mem_fn(R (T::* pm)(Args...) const volatile
   &&);

   Function template std::mem_fn generates wrapper objects for pointers to members,
   which can store, copy, and invoke a pointer to member. Both references and pointers
   (including smart pointers) to an object can be used when invoking a std::mem_fn.

   The overloads \fB(2)\fP were introduced in C++11 but removed in C++14 as defect #2048

.SH Parameters

   pm - pointer to member that will be wrapped

.SH Return value

   std::mem_fn returns a call wrapper of unspecified type that has the following
   members:

std::mem_fn Return type

.SH Member types

   type                                      definition
                                             the return type of pm if pm is a pointer
   result_type(deprecated in C++17)          to member function, not defined for
                                             pointer to member object
                                             T*, possibly cv-qualified, if pm is a
   argument_type(deprecated in C++17)        pointer to member function taking no
                                             arguments
   first_argument_type(deprecated in C++17)  T* if pm is a pointer to member function
                                             taking one argument
   second_argument_type(deprecated in C++17) T1 if pm is a pointer to member function
                                             taking one argument of type T1

.SH Member function

   template<class... Args>
   /* see below */ operator()(Args&&... args);

   Let fn be the call wrapper returned by a call to std::mem_fn with a pointer to
   member pm. Then the expression fn(t, a2, ..., aN) is equivalent to INVOKE(pm, t, a2,
   ..., aN), where INVOKE is the operation defined in Callable. (Thus, the return type
   of operator() is std::result_of<decltype(pm)(Args&&...)>::type.)

   Each argument in args is perfectly forwarded, as if by std::forward<Args>(args)....

.SH Exceptions

   \fI(none)\fP                    \fI(until C++17)\fP
   noexcept specification:  
   noexcept                  \fI(since C++17)\fP
     

.SH Example 1

   Use mem_fn to store and execute a member function and a member object:

   
// Run this code

 #include <functional>
 #include <iostream>
  
 struct Foo {
     void display_greeting() {
         std::cout << "Hello, world.\\n";
     }
     void display_number(int i) {
         std::cout << "number: " << i << '\\n';
     }
     int data = 7;
 };
  
 int main() {
     Foo f;
  
     auto greet = std::mem_fn(&Foo::display_greeting);
     greet(f);
  
     auto print_num = std::mem_fn(&Foo::display_number);
     print_num(f, 42);
  
     auto access_data = std::mem_fn(&Foo::data);
     std::cout << "data: " << access_data(f) << '\\n';
 }

.SH Output:

 Hello, world.
 number: 42
 data: 7

.SH Example 2

   Demonstrates the effect of the C++14 changes to the specification of std::mem_fn

   
// Run this code

 #include <iostream>
 #include <functional>
  
 struct X {
     int x;
  
     int&       easy()      {return x;}
     int&       get()       {return x;}
     const int& get() const {return x;}
 };
  
  
 int main(void)
 {
     auto a = std::mem_fn        (&X::easy); // no problem at all
 //  auto b = std::mem_fn<int&  >(&X::get ); // no longer works in C++14
     auto c = std::mem_fn<int&()>(&X::get ); // works with both C++11 and C++14
     auto d = [] (X& x) {return x.get();};   // another approach to overload resolution
  
     X x = {33};
     std::cout << "a() = " << a(x) << '\\n';
     std::cout << "c() = " << c(x) << '\\n';
     std::cout << "d() = " << d(x) << '\\n';
 }

.SH Output:

 a() = 33
 c() = 33
 d() = 33

.SH See also

   function wraps callable object of any type with specified function call signature
   \fI(C++11)\fP  \fI(class template)\fP 
   bind     binds one or more arguments to a function object
   \fI(C++11)\fP  \fI(function template)\fP 

.SH Category:

     * unconditionally noexcept

   Hidden categories:

     * Pages with unreviewed unconditional noexcept template
     * Pages with unreviewed noexcept template
