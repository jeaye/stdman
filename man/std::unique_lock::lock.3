.TH std::unique_lock::lock 3 "Apr 19 2014" "1.0.0" "C++ Standard Libary"
.SH Synopsis
   void lock();  \fI(since C++11)\fP

   Locks the associated mutex. Effectively calls mutex()->lock().

   std::system_error is thrown if there is no associated mutex or if the mutex is
   already locked.

.SH Contents

     • 1 Parameters
     • 2 Return value
     • 3 Exceptions
     • 4 Example
     • 5 See also

.SH Parameters

   \fI(none)\fP

.SH Return value

   \fI(none)\fP

.SH Exceptions

     • Any exceptions thrown by mutex()->lock()

     • If there is no associated mutex, std::system_error with an error code of
       std::errc::operation_not_permitted

     • If the mutex is already locked, std::system_error with an error code of
       std::errc::resource_deadlock_would_occur

.SH Example

   The following example uses lock to re-acquire a mutex that was unlocked.

   
// Run this code

 #include <mutex>
 #include <thread>
 #include <iostream>
 #include <vector>
 #include <chrono>

 int main()
 {
     int counter = 0;
     std::mutex counter_mutex;
     std::vector<std::thread> threads;

     auto worker_task = [&](int id) {
         std::unique_lock<std::mutex> lock(counter_mutex);
         ++counter;
         std::cout << id << ", initial counter: " << counter << '\\n';
         lock.unlock();

         // don't hold the lock while we simulate an expensive operation
         std::this_thread::sleep_for(std::chrono::seconds(1));

         lock.lock();
         ++counter;
         std::cout << id << ", final counter: " << counter << '\\n';
     };

     for (int i = 0; i < 10; ++i) threads.emplace_back(worker_task, i);

     for (auto &thread : threads) thread.join();
 }

.SH Possible output:

 0, initial counter: 1
 1, initial counter: 2
 2, initial counter: 3
 3, initial counter: 4
 4, initial counter: 5
 5, initial counter: 6
 6, initial counter: 7
 7, initial counter: 8
 8, initial counter: 9
 9, initial counter: 10
 6, final counter: 11
 3, final counter: 12
 4, final counter: 13
 2, final counter: 14
 5, final counter: 15
 0, final counter: 16
 1, final counter: 17
 7, final counter: 18
 9, final counter: 19
 8, final counter: 20

.SH See also

   try_lock tries to lock the associated mutex, returns if the mutex is not available
            \fI(public member function)\fP
   unlock   unlocks the associated mutex
            \fI(public member function)\fP
