.TH std::trunc 3 "Nov 25 2015" "2.0 | http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::trunc \- std::trunc

.SH Synopsis
   Defined in header <cmath>
   float       trunc( float arg );       \fB(1)\fP \fI(since C++11)\fP
   double      trunc( double arg );      \fB(2)\fP \fI(since C++11)\fP
   long double trunc( long double arg ); \fB(3)\fP \fI(since C++11)\fP
   double      trunc( Integral arg );    \fB(4)\fP \fI(since C++11)\fP

   1-3) Computes the nearest integer not greater in magnitude than arg.
   4) A set of overloads or a function template accepting an argument of any integral
   type. Equivalent to 2) (the argument is cast to double).

.SH Parameters

   arg - floating point value

.SH Return value

   If no errors occur, the nearest integer value not greater in magnitude than arg (in
   other words, arg rounded towards zero), is returned.

.SH Return value
   math-trunc.svg
   Argument

.SH Error handling

   Errors are reported as specified in math_errhandling

   If the implementation supports IEEE floating-point arithmetic (IEC 60559),

     * The current rounding mode has no effect.
     * If arg is ±∞, it is returned, unmodified
     * If arg is ±0, it is returned, unmodified
     * If arg is NaN, NaN is returned

.SH Notes

   FE_INEXACT may be (but isn't required to be) raised when truncating a non-integer
   finite value.

   The largest representable floating-point values are exact integers in all standard
   floating-point formats, so this function never overflows on its own; however the
   result may overflow any integer type (including std::intmax_t), when stored in an
   integer variable.

   The implicit conversion from floating-point to integral types also rounds towards
   zero, but is limited to the values that can be represented by the target type.

.SH Example

   
// Run this code

 #include <cmath>
 #include <iostream>
 int main()
 {
     std::cout << std::fixed
               << "trunc(+2.7) = " << std::trunc(+2.7) << '\\n'
               << "trunc(-2.9) = " << std::trunc(-2.9) << '\\n'
               << "trunc(-0.0) = " << std::trunc(-0.0) << '\\n'
               << "trunc(-Inf) = " << std::trunc(-INFINITY) << '\\n';
 }

.SH Possible output:

 trunc(+2.7) = 2.000000
 trunc(-2.9) = -2.000000
 trunc(-0.0) = -0.000000
 trunc(-Inf) = -inf

.SH See also

   floor   nearest integer not greater than the given value
           \fI(function)\fP 
   ceil    nearest integer not less than the given value
           \fI(function)\fP 
   round
   lround
   llround nearest integer, rounding away from zero in halfway cases
   \fI(C++11)\fP \fI(function)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   C documentation for
   trunc
