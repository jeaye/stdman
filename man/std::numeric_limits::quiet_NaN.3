.TH std::numeric_limits::quiet_NaN 3 "2020.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::quiet_NaN \- std::numeric_limits::quiet_NaN

.SH Synopsis
   static T quiet_NaN() throw();             \fI(until C++11)\fP
   static constexpr T quiet_NaN() noexcept;  \fI(since C++11)\fP

   Returns the special value "quiet not-a-number", as represented by the floating-point
   type T. Only meaningful if std::numeric_limits<T>::has_quiet_NaN == true. In IEEE
   754, the most common binary representation of floating-point numbers, any value with
   all bits of the exponent set and at least one bit of the fraction set represents a
   NaN. It is implementation-defined which values of the fraction represent quiet or
   signaling NaNs, and whether the sign bit is meaningful.

.SH Return value

   T                     std::numeric_limits<T>::quiet_NaN()
   /* non-specialized */ T()
   bool                  false
   char                 
   signed char          
   unsigned char        
   wchar_t              
   char8_t              
   char16_t             
   char32_t             
   short                
   unsigned short       
   int                  
   unsigned int         
   long                 
   unsigned long        
   long long            
   unsigned long long   
   float                 NAN or another implementation-defined NaN
   double                implementation-defined
   long double           implementation-defined

.SH Notes

   A NaN never compares equal to itself. Copying a NaN may not preserve its bit
   representation.

.SH Example

   Several ways to generate a NaN (the output string is compiler-specific)

   
// Run this code

 #include <iostream>
 #include <limits>
 #include <cmath>
  
 int main()
 {
     std::cout << std::numeric_limits<double>::quiet_NaN() << ' '
               << std::numeric_limits<double>::signaling_NaN() << ' '
               << std::acos(2) << ' '
               << std::tgamma(-1) << ' '
               << std::log(-1) << ' '
               << std::sqrt(-1) << ' '
               << 0 / 0.0 << '\\n';
  
     std::cout << "NaN == NaN? " << std::boolalpha
               << ( std::numeric_limits<double>::quiet_NaN()
                    == std::numeric_limits<double>::quiet_NaN() ) << '\\n';
 }

.SH Output:

 nan nan nan nan nan -nan -nan
 NaN == NaN? false

.SH See also

   has_quiet_NaN identifies floating-point types that can represent the special value
   \fB[static]\fP      "quiet not-a-number" (NaN)
                 \fI(public static member constant)\fP 
   signaling_NaN returns a signaling NaN value of the given floating-point type
   \fB[static]\fP      \fI(public static member function)\fP 
   nan
   nanf
   nanl          not-a-number (NaN)
   \fI(C++11)\fP       \fI(function)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   isnan         checks if the given number is NaN
   \fI(C++11)\fP       \fI(function)\fP 
