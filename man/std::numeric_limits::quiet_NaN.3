.TH std::numeric_limits::quiet_NaN 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::quiet_NaN \- std::numeric_limits::quiet_NaN

.SH Synopsis
   static T quiet_NaN();            \fI(until C++11)\fP
   static constexpr T quiet_NaN();  \fI(since C++11)\fP

   Returns the special value "quiet not-a-number", as represented by the floating-point
   type T. Only meaningful if std::numeric_limits<T>::has_quiet_NaN == true. In IEEE
   754, the most common binary representation of floating-point numbers, any value with
   all bits of the exponent set and at least one bit of the fraction set represents a
   NaN. It is implementation-defined which values of the fraction represent quiet or
   signaling NaNs, and whether the sign bit is meaningful.

.SH Return value

   T                     std::numeric_limits<T>::quiet_NaN()
   /* non-specialized */ T();
   bool                  false
   char                  0
   signed char           0
   unsigned char         0
   wchar_t               0
   char16_t              0
   char32_t              0
   short                 0
   unsigned short        0
   int                   0
   unsigned int          0
   long                  0
   unsigned long         0
   long long             0
   unsigned long long    0
   float                 NAN or another implementation-defined NaN
   double                implementation-defined
   long double           implementation-defined

.SH Exceptions

   \fI(none)\fP                    \fI(until C++11)\fP
   noexcept specification:  
   noexcept                  \fI(since C++11)\fP
     

.SH Notes

   A NaN never compares equal to itself. Copying a NaN may not preserve its bit
   representation.

.SH Example

   Several ways to generate a NaN (the output string is compiler-specific)

   
// Run this code

 #include <iostream>
 #include <limits>
 #include <cmath>
  
 int main()
 {
     std::cout << std::numeric_limits<double>::quiet_NaN() << ' '
               << std::numeric_limits<double>::signaling_NaN() << ' '
               << std::acos(2) << ' '
               << std::tgamma(-1) << ' '
               << std::log(-1) << ' '
               << std::sqrt(-1) << ' '
               << 0 / 0.0 << '\\n';
  
     std::cout << "NaN == NaN? " << std::boolalpha
               << ( std::numeric_limits<double>::quiet_NaN()
                    == std::numeric_limits<double>::quiet_NaN() ) << '\\n';
 }

.SH Output:

 nan nan nan nan nan -nan -nan
 NaN == NaN? false

.SH See also

   has_quiet_NaN identifies floating-point types that can represent the special value
   \fB[static]\fP      "quiet not-a-number" (NaN)
                 \fI(public static member constant)\fP 
   signaling_NaN returns a signaling NaN value of the given floating-point type
   \fB[static]\fP      \fI(public static member function)\fP 
   nan
   nanf
   nanl          not-a-number (NaN)
   \fI(C++11)\fP       \fI(function)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   isnan         checks if the given number is NaN
   \fI(C++11)\fP       \fI(function)\fP 

.SH Category:

     * unconditionally noexcept

   Hidden categories:

     * Pages with unreviewed unconditional noexcept template
     * Pages with unreviewed noexcept template
