.TH std::make_unsigned 3 "2017.04.02" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::make_unsigned \- std::make_unsigned

.SH Synopsis
   Defined in header <type_traits>
   template< class T >              \fI(since C++11)\fP
   struct make_unsigned;

   If T is an integral (except bool) or enumeration type, provides the member typedef
   type which is the unsigned integer type corresponding to T, with the same
   cv-qualifiers.

   Otherwise, the behavior is undefined.

.SH Member types

   Name Definition
   type the unsigned integer type corresponding to T

.SH Helper types

   template< class T >                                       \fI(since C++14)\fP
   using make_unsigned_t = typename make_unsigned<T>::type;

.SH Example

   
// Run this code

 #include <iostream>
 #include <type_traits>
  
 int main() {
     typedef std::make_unsigned<char>::type char_type;
     typedef std::make_unsigned<int>::type int_type;
     typedef std::make_unsigned<volatile long>::type long_type;
  
     bool ok1 = std::is_same<char_type, unsigned char>::value;
     bool ok2 = std::is_same<int_type, unsigned int>::value;
     bool ok3 = std::is_same<long_type, volatile unsigned long>::value;
  
     std::cout << std::boolalpha
     << "char_type is 'unsigned char'?          : " << ok1 << '\\n'
     << "int_type  is 'unsigned int'?           : " << ok2 << '\\n'
     << "long_type is 'volatile unsigned long'? : " << ok3 << '\\n';
 }

.SH Output:

 char_type is 'unsigned char'?          : true
 int_type  is 'unsigned int'?           : true
 long_type is 'volatile unsigned long'? : true

.SH See also

   is_signed   checks if a type is signed arithmetic type
   \fI(C++11)\fP     \fI(class template)\fP 
   is_unsigned checks if a type is unsigned arithmetic type
   \fI(C++11)\fP     \fI(class template)\fP 
   make_signed makes the given integral type signed
   \fI(C++11)\fP     \fI(class template)\fP 
