.TH std::make_unsigned 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::make_unsigned \- std::make_unsigned

.SH Synopsis
   Defined in header <type_traits>
   template< class T >              \fI(since C++11)\fP
   struct make_unsigned;

   If T is an integral (except bool) or enumeration type, provides the member typedef
   type which is the unsigned integer type corresponding to T, with the same
   cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the
   unsigned integer type with the smallest rank having the same sizeof as the
   enumeration.

   Otherwise, the behavior is undefined.

.SH Member types

   Name Definition
   type the unsigned integer type corresponding to T

.SH Helper types

   template< class T >                                       \fI(since C++14)\fP
   using make_unsigned_t = typename make_unsigned<T>::type;

.SH Example

   
// Run this code

 #include <iostream>
 #include <type_traits>
  
 int main() {
     typedef std::make_unsigned<char>::type char_type;
     typedef std::make_unsigned<int>::type int_type;
     typedef std::make_unsigned<volatile long>::type long_type;
  
     bool ok1 = std::is_same<char_type, unsigned char>::value;
     bool ok2 = std::is_same<int_type, unsigned int>::value;
     bool ok3 = std::is_same<long_type, volatile unsigned long>::value;
  
     std::cout << std::boolalpha
     << "char_type is 'unsigned char'?          : " << ok1 << '\\n'
     << "int_type  is 'unsigned int'?           : " << ok2 << '\\n'
     << "long_type is 'volatile unsigned long'? : " << ok3 << '\\n';
 }

.SH Output:

 char_type is 'unsigned char'?          : true
 int_type  is 'unsigned int'?           : true
 long_type is 'volatile unsigned long'? : true

.SH See also

   is_signed   checks if a type is signed arithmetic type
   \fI(C++11)\fP     \fI(class template)\fP 
   is_unsigned checks if a type is unsigned arithmetic type
   \fI(C++11)\fP     \fI(class template)\fP 
   make_signed makes the given integral type signed
   \fI(C++11)\fP     \fI(class template)\fP 
