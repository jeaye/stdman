.TH std::priority_queue::priority_queue 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::priority_queue::priority_queue \- std::priority_queue::priority_queue

.SH Synopsis
   priority_queue() : priority_queue(Compare(),             \fB(1)\fP (since
   Container()) {}                                              C++11)
   explicit priority_queue( const Compare& compare )        \fB(2)\fP (since
       : priority_queue(compare, Container()) {}                C++11)
   explicit priority_queue( const Compare& compare =
   Compare(),                                                           (until
                            const Container& cont =                     C++11)
   Container() );
   priority_queue( const Compare& compare, const Container&             (since
   cont );                                                              C++11)
   priority_queue( const Compare& compare, Container&& cont     \fB(4)\fP     (since
   );                                                                   C++11)
   priority_queue( const priority_queue& other );               \fB(5)\fP
   priority_queue( priority_queue&& other );                    \fB(6)\fP     (since
                                                                        C++11)
   template< class InputIt >
                                                                        (since
   priority_queue( InputIt first, InputIt last,                 \fB(7)\fP     C++11)

                   const Compare& compare = Compare() );
   template< class InputIt >

   priority_queue( InputIt first, InputIt last,                                 (until
                   const Compare& compare = Compare(),                          C++11)

                   const Container& cont = Container() );
   template< class InputIt >

   priority_queue( InputIt first, InputIt last,                                 (since
                                                                                C++11)
                   const Compare& compare, const Container&
   cont );
   template< class InputIt >

   priority_queue( InputIt first, InputIt last,                         \fB(9)\fP     (since
                                                                                C++11)
                   const Compare& compare, Container&& cont
   );
   template< class Alloc >                                              \fB(10)\fP    (since
   explicit priority_queue( const Alloc& alloc );                               C++11)
   template< class Alloc >                                                      (since
   priority_queue( const Compare& compare, const Alloc&                 \fB(11)\fP    C++11)
   alloc );
   template< class Alloc >

   priority_queue( const Compare& compare, const Container&             \fB(12)\fP    (since
   cont,                                                                        C++11)

                   const Alloc& alloc );
   template< class Alloc >
                                                            \fB(3)\fP
   priority_queue( const Compare& compare, Container&&                  \fB(13)\fP    (since
   cont,                                                                        C++11)

                   const Alloc& alloc );
   template< class Alloc >                                                      (since
   priority_queue( const priority_queue& other, const                   \fB(14)\fP    C++11)
   Alloc& alloc );
   template< class Alloc >                                      \fB(8)\fP             (since
   priority_queue( priority_queue&& other, const Alloc&                 \fB(15)\fP    C++11)
   alloc );
   template< class InputIt, class Alloc >                                       (since
   priority_queue( InputIt first, InputIt last, const                   \fB(16)\fP    C++11)
   Alloc& alloc );
   template< class InputIt, class Alloc >

   priority_queue( InputIt first, InputIt last, const                   \fB(17)\fP    (since
   Compare& compare,                                                            C++11)

                   const Alloc& alloc );
   template< class InputIt, class Alloc >

   priority_queue( InputIt first, InputIt last, const                           (since
   Compare& compare,                                                    \fB(18)\fP    C++11)

                   const Container& cont, const Alloc&
   alloc );
   template< class InputIt, class Alloc >

   priority_queue( InputIt first, InputIt last, const                   \fB(19)\fP    (since
   Compare& compare,                                                            C++11)

                   Container&& cont, const Alloc& alloc );
   template< container-compatible-range<T> R >
                                                                                (since
   priority_queue( std::from_range_t, R&& rg,                           \fB(20)\fP    C++23)

                   const Compare& compare = Compare() );
   template< container-compatible-range<T> R, class Alloc >

   priority_queue( std::from_range_t, R&& rg,                           \fB(21)\fP    (since
                                                                                C++23)
                   const Compare& compare, const Alloc&
   alloc );
   template< container-compatible-range<T> R, class Alloc >                     (since
   priority_queue( std::from_range_t, R&& rg, const Alloc&              \fB(22)\fP    C++23)
   alloc );

   Constructs new underlying container of the container adaptor from a variety of data
   sources.

   1) Default constructor. Value-initializes the comparator and the underlying
   container.
   2) Copy-constructs the comparison functor comp with the contents of compare.
   Value-initializes the underlying container c.
   3) Copy-constructs the underlying container c with the contents of cont.
   Copy-constructs the comparison functor comp with the contents of compare. Calls
   std::make_heap(c.begin(), c.end(), comp).
   This is also the default constructor.
   \fI(until C++11)\fP
   4) Move-constructs the underlying container c with std::move(cont). Copy-constructs
   the comparison functor comp with compare. Calls std::make_heap(c.begin(), c.end(),
   comp).
   5) Copy constructor. The underlying container is copy-constructed with other.c. The
   comparison functor is copy-constructed with other.comp. (implicitly declared)
   6) Move constructor. The underlying container is constructed with
   std::move(other.c). The comparison functor is constructed with
   std::move(other.comp). (implicitly declared)
   7-9) Iterator-pair constructors. These overloads participate in overload resolution
   only if InputIt satisfies LegacyInputIterator.
   7) Constructs c as if by c(first, last) and comp from compare. Then calls
   std::make_heap(c.begin(), c.end(), comp);.
   8) Copy-constructs c from cont and comp from compare. Then calls c.insert(c.end(),
   first, last);, and then calls std::make_heap(c.begin(), c.end(), comp);.
   9) Move-constructs c from std::move(cont) and copy-constructs comp from compare.
   Then calls c.insert(c.end(), first, last);, and then calls std::make_heap(c.begin(),
   c.end(), comp);.
   10-15) Allocator-extended constructors. These overloads participate in overload
   resolution only if std::uses_allocator<container_type, Alloc>::value is true, that
   is, if the underlying container is an allocator-aware container (true for all
   standard library containers).
   10) Constructs the underlying container using alloc as allocator. Effectively calls
   c(alloc). comp is value-initialized.
   11) Constructs the underlying container using alloc as allocator. Effectively calls
   c(alloc). Copy-constructs comp from compare.
   12) Constructs the underlying container with the contents of cont and using alloc as
   allocator, as if by c(cont, alloc). Copy-constructs comp from compare. Then calls
   std::make_heap(c.begin(), c.end(), comp).
   13) Constructs the underlying container with the contents of cont using move
   semantics while using alloc as allocator, as if by c(std::move(cont), alloc).
   Copy-constructs comp from compare. Then calls std::make_heap(c.begin(), c.end(),
   comp).
   14) Constructs the underlying container with the contents of other.c and using alloc
   as allocator. Effectively calls c(other.c, alloc). Copy-constructs comp from
   other.comp.
   15) Constructs the underlying container with the contents of other using move
   semantics while utilizing alloc as allocator. Effectively calls
   c(std::move(other.c), alloc). Move-constructs comp from other.comp.
   16-19) Allocator-extended iterator-pair constructors. Same as (7-9), except that
   alloc is used for constructing the underlying container. These overloads participate
   in overload resolution only if std::uses_allocator<container_type, Alloc>::value is
   true and InputIt satisfies LegacyInputIterator.
   20) Initializes comp with compare and c with
   ranges::to<Container>(std::forward<R>(rg)). Then calls std::make_heap(c.begin(),
   c.end(), comp).
   21) Initializes comp with compare and c with
   ranges::to<Container>(std::forward<R>(rg), alloc). Then calls
   std::make_heap(c.begin(), c.end(), comp).
   22) Initializes c with ranges::to<Container>(std::forward<R>(rg), alloc). Then calls
   std::make_heap(c.begin(), c.end(), comp).

   Note that how an implementation checks whether a type satisfies LegacyInputIterator
   is unspecified, except that integral types are required to be rejected.

.SH Parameters

   alloc             -       allocator to use for all memory allocations of the
                             underlying container
   other             -       another container adaptor to be used as source to
                             initialize the underlying container
   cont              -       container to be used as source to initialize the
                             underlying container
   compare           -       the comparison function object to initialize the
                             underlying comparison functor
   first, last       -       a range [first, last) of elements to initialize with
   rg                -       a container compatible range, that is, an input_range
                             whose elements are convertible to T
.SH Type requirements
   -
   Alloc must meet the requirements of Allocator.
   -
   Compare must meet the requirements of Compare.
   -
   Container must meet the requirements of Container. The allocator-extended
   constructors are only defined if Container meets the requirements of
   AllocatorAwareContainer.
   -
   InputIt must meet the requirements of LegacyInputIterator.

.SH Complexity

   1,2) Constant.
   3,5,12) \\(\\scriptsize \\mathcal{O}{(N)}\\)O(N) comparisons and \\(\\scriptsize
   \\mathcal{O}{(N)}\\)O(N) calls to the constructor of value_type, where \\(\\scriptsize
   N\\)N is cont.size().
   4) \\(\\scriptsize \\mathcal{O}{(N)}\\)O(N) comparisons, where \\(\\scriptsize N\\)N is
   cont.size().
   6) Constant.
   7,16,17) \\(\\scriptsize \\mathcal{O}{(M)}\\)O(M) comparisons, where \\(\\scriptsize M\\)M
   is std::distance(first, last).
   8,18) \\(\\scriptsize \\mathcal{O}{(N + M)}\\)O(N + M) comparisons and \\(\\scriptsize
   \\mathcal{O}{(N)}\\)O(N) calls to the constructor of value_type, where \\(\\scriptsize
   N\\)N is cont.size() and \\(\\scriptsize M\\)M is std::distance(first, last).
   9) \\(\\scriptsize \\mathcal{O}{(N + M)}\\)O(N + M) comparisons, where \\(\\scriptsize
   N\\)N is cont.size() and \\(\\scriptsize M\\)M is std::distance(first, last).
   10,11) Constant.
   13) \\(\\scriptsize \\mathcal{O}{(N)}\\)O(N) comparisons, where \\(\\scriptsize N\\)N is
   cont.size().
   14) Linear in size of other.
   15) Constant if Alloc compares equal to the allocator of other. Linear in size of
   other otherwise.
   19) \\(\\scriptsize \\mathcal{O}{(N + M)}\\)O(N + M) comparisons and possibly
   \\(\\scriptsize \\mathcal{O}{(N)}\\)O(N) calls to the constructor of value_type (present
   if Alloc does not compare equal to the allocator of other), where \\(\\scriptsize N\\)N
   is cont.size() and \\(\\scriptsize M\\)M is std::distance(first, last).
   20) \\(\\scriptsize \\mathcal{O}{(N)}\\)O(N) comparisons and \\(\\scriptsize
   \\mathcal{O}{(N)}\\)O(N) calls to the constructor of value_type, where \\(\\scriptsize
   N\\)N is ranges::distance(rg).
   21,22)

    This section is incomplete

.SH Notes

       Feature-test macro       Value    Std                   Feature
   __cpp_lib_containers_ranges 202202L (C++23) Ranges-aware construction and insertion;
                                               overloads (20-22)

.SH Example


// Run this code

 #include <complex>
 #include <functional>
 #include <iostream>
 #include <queue>
 #include <vector>

 int main()
 {
     std::priority_queue<int> pq1;
     pq1.push(5);
     std::cout << "pq1.size() = " << pq1.size() << '\\n';

     std::priority_queue<int> pq2 {pq1};
     std::cout << "pq2.size() = " << pq2.size() << '\\n';

     std::vector<int> vec {3, 1, 4, 1, 5};
     std::priority_queue<int> pq3 {std::less<int>(), vec};
     std::cout << "pq3.size() = " << pq3.size() << '\\n';

     for (std::cout << "pq3 : "; !pq3.empty(); pq3.pop())
         std::cout << pq3.top() << ' ';
     std::cout << '\\n';

     // Demo With Custom Comparator:

     using my_value_t = std::complex<double>;
     using my_container_t = std::vector<my_value_t>;

     auto my_comp = [](const my_value_t& z1, const my_value_t& z2)
     {
         return z2.real() < z1.real();
     };

     std::priority_queue<my_value_t,
                         my_container_t,
                         decltype(my_comp)> pq4{my_comp};

     using namespace std::complex_literals;
     pq4.push(5.0 + 1i);
     pq4.push(3.0 + 2i);
     pq4.push(7.0 + 3i);

     for (; !pq4.empty(); pq4.pop())
     {
         const auto& z = pq4.top();
         std::cout << "pq4.top() = " << z << '\\n';
     }

     // TODO: C++23 range-aware ctors
 }

.SH Output:

 pq1.size() = 1
 pq2.size() = 1
 pq3.size() = 5
 pq3 : 5 4 3 1 1
 pq4.top() = (3,2)
 pq4.top() = (5,1)
 pq4.top() = (7,3)

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to          Behavior as published              Correct behavior
   P0935R0  C++11      default constructor and constructor \fB(4)\fP made implicit
                       were explicit
   LWG 3506 C++11      allocator-extended iterator-pair        added
                       constructors were missing
   LWG 3522 C++11      constraints on iterator-pair            added
                       constructors were missing
   LWG 3529 C++11      construction from a pair of iterators   constructs the container
                       called insert                           from them

.SH See also

   operator= assigns values to the container adaptor
             \fI(public member function)\fP

.SH Category:
     * Todo without reason
