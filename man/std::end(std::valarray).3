.TH std::end(std::valarray) 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::end(std::valarray) \- std::end(std::valarray)

.SH Synopsis
   template< class T >                           \fB(1)\fP \fI(since C++11)\fP
   /*unspecified1*/ end( valarray<T>& v );
   template< class T >                           \fB(2)\fP \fI(since C++11)\fP
   /*unspecified2*/ end( const valarray<T>& v );

   The overload of std::end for valarray returns an iterator of unspecified type
   referring to the one past the last element in the numeric array.

   1) The return type meets the requirements of mutable LegacyRandomAccessIterator.
   2) The return type meets the requirements of constant LegacyRandomAccessIterator.

   The iterator obtained from this function template is invalidated when the member
   function resize() is called on the array v or when the lifetime of v ends, whichever
   comes first.

.SH Parameters

   v - a numeric array

.SH Return value

   Iterator to one past the last value in the numeric array.

.SH Exceptions

   May throw implementation-defined exceptions.

.SH Notes

   Unlike other functions that take std::valarray arguments, end() cannot accept the
   replacement types (such as the types produced by expression templates) that may be
   returned from expressions involving valarrays: std::end(v1 + v2) is not portable,
   std::end(std::valarray<T>(v1 + v2)) has to be used instead.

   The intent of this function is to allow range for loops to work with valarrays, not
   to provide container semantics.

.SH Example


// Run this code

 #include <iostream>
 #include <valarray>
 #include <algorithm>

 int main()
 {
     const std::valarray<char> va {
         'H', 'e', 'l', 'l', 'o',
         ',', ' ',
         'C', '+', '+', '!', '\\n'
     };

     std::for_each(
         std::begin(va),
         std::end(va),
         [](char c) {
             std::cout << c;
         });
 }

.SH Possible output:

 Hello, C++!

.SH See also

   std::begin(std::valarray) specializes std::begin
   \fI(C++11)\fP                   \fI(function template)\fP
