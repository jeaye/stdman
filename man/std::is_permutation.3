.TH std::is_permutation 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::is_permutation \- std::is_permutation

.SH Synopsis
   Defined in header <algorithm>
   template< class ForwardIt1, class ForwardIt2
   >                                                    (since
                                                        C++11)
   bool is_permutation( ForwardIt1 first1,              (until
   ForwardIt1 last1,                                    C++20)

                        ForwardIt2 first2 );
   template< class ForwardIt1, class ForwardIt2
   >

   constexpr bool is_permutation( ForwardIt1            (since
   first1, ForwardIt1 last1,                            C++20)

                                  ForwardIt2
   first2 );
   template< class ForwardIt1, class
   ForwardIt2, class BinaryPredicate >
                                                                (since
   bool is_permutation( ForwardIt1 first1,                      C++11)
   ForwardIt1 last1,                                            (until
                                                                C++20)
                        ForwardIt2 first2,
   BinaryPredicate p );
   template< class ForwardIt1, class
   ForwardIt2, class BinaryPredicate >

   constexpr bool is_permutation( ForwardIt1                    (since
   first1, ForwardIt1 last1,                                    C++20)

                                  ForwardIt2
   first2, BinaryPredicate p );
   template< class ForwardIt1, class ForwardIt2
   >                                            \fB(1)\fP
                                                                        (since
   bool is_permutation( ForwardIt1 first1,                              C++14)
   ForwardIt1 last1,                                                    (until
                                                                        C++20)
                        ForwardIt2 first2,
   ForwardIt2 last2 );
   template< class ForwardIt1, class ForwardIt2
   >                                                \fB(2)\fP

   constexpr bool is_permutation( ForwardIt1                            (since
   first1, ForwardIt1 last1,                                            C++20)

                                  ForwardIt2
   first2, ForwardIt2 last2 );
   template< class ForwardIt1, class
   ForwardIt2, class BinaryPredicate >                  \fB(3)\fP
                                                                                (since
   bool is_permutation( ForwardIt1 first1,                                      C++14)
   ForwardIt1 last1,                                                            (until
                        ForwardIt2 first2,                                      C++20)
   ForwardIt2 last2,

                        BinaryPredicate p );
   template< class ForwardIt1, class                            \fB(4)\fP
   ForwardIt2, class BinaryPredicate >

   constexpr bool is_permutation( ForwardIt1
   first1, ForwardIt1 last1,                                                    (since
                                  ForwardIt2                                    C++20)
   first2, ForwardIt2 last2,


    BinaryPredicate p );

   Returns true if there exists a permutation of the elements in the range [first1,
   last1) that makes that range equal to the range [first2,last2), where last2 denotes
   first2 + (last1 - first1) if it was not given.

   1,3) Elements are compared using operator==. The behavior is undefined if it is not
   an equivalence relation.
   2,4) Elements are compared using the given binary predicate p. The behavior is
   undefined if it is not an equivalence relation.

.SH Parameters

   first1, last1 - the range of elements to compare
   first2, last2 - the second range to compare
                   binary predicate which returns true if the elements should be
                   treated as equal.

                   The signature of the predicate function should be equivalent to the
                   following:
   p             -
                    bool pred(const Type &a, const Type &b);

                   Type should be the value type of both ForwardIt1 and ForwardIt2. The
                   signature does not need to have const &, but the function must not
                   modify the objects passed to it.
.SH Type requirements
   -
   ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator.
   -
   ForwardIt1, ForwardIt2 must have the same value type.

.SH Return value

   true if the range [first1, last1) is a permutation of the range [first2, last2).

.SH Complexity

   At most O(N^2) applications of the predicate, or exactly N if the sequences are
   already equal, where N=std::distance(first1, last1).

   However if ForwardIt1 and ForwardIt2 meet the requirements of
   LegacyRandomAccessIterator and std::distance(first1, last1) != std::distance(first2,
   last2) no applications of the predicate are made.

.SH Possible implementation

   template<class ForwardIt1, class ForwardIt2>
   bool is_permutation(ForwardIt1 first, ForwardIt1 last,
                       ForwardIt2 d_first)
   {
       // skip common prefix
       std::tie(first, d_first) = std::mismatch(first, last, d_first);
       // iterate over the rest, counting how many times each element
       // from [first, last) appears in [d_first, d_last)
       if (first != last) {
           ForwardIt2 d_last = std::next(d_first, std::distance(first, last));
           for (ForwardIt1 i = first; i != last; ++i) {
               if (i != std::find(first, i, *i)) continue; // this *i has been checked

               auto m = std::count(d_first, d_last, *i);
               if (m==0 || std::count(i, last, *i) != m) {
                   return false;
               }
           }
       }
       return true;
   }

.SH Note

   One of the use of std::is_permutation is to ensure that after some rearrangements
   (e.g. sorting, shuffling, or partitioning) of a range that range still contains the
   same elements, maybe staying at other positions. The property P to be a permutation
   is reflexive, commutative, and transitive. That is

     * P(r1, r1) is always true;
     * P(r1, r2) == true => P(r2, r1) == true;
     * P(r1, r2) == true && P(r2, r3) == true => P(r1, r3) == true,

   where r1, r2, r3 are some ranges.

.SH Example


// Run this code

 #include <iostream>
 #include <algorithm>

 template<typename Os, typename V>
 Os& operator<< (Os& os, V const& v) {
     os << "{ ";
     for (auto const& e : v) os << e << ' ';
     return os << "}";
 }

 int main()
 {
     static constexpr auto v1 = {1,2,3,4,5};
     static constexpr auto v2 = {3,5,4,1,2};
     static constexpr auto v3 = {3,5,4,1,1};

     std::cout << v2 << " is a permutation of " << v1 << ": " << std::boolalpha
               << std::is_permutation(v1.begin(), v1.end(), v2.begin()) << '\\n'
               << v3 << " is a permutation of " << v1 << ": " << std::boolalpha
               << std::is_permutation(v1.begin(), v1.end(), v3.begin()) << '\\n';
 }

.SH Output:

 { 3 5 4 1 2 } is a permutation of { 1 2 3 4 5 }: true
 { 3 5 4 1 1 } is a permutation of { 1 2 3 4 5 }: false

.SH See also

                    generates the next greater lexicographic permutation of a range of
   next_permutation elements
                    \fI(function template)\fP
                    generates the next smaller lexicographic permutation of a range of
   prev_permutation elements
                    \fI(function template)\fP
