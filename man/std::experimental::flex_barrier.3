.TH std::experimental::flex_barrier 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::experimental::flex_barrier \- std::experimental::flex_barrier

.SH Synopsis
   Defined in header <experimental/barrier>
   class flex_barrier;                       (concurrency TS)

   The class std::experimental::flex_barrier provides a thread-coordination mechanism
   that allows a set of participating threads to block until an operation is completed.
   Unlike std::experimental::latch, barriers are reusable; once the participating
   threads are released from a barrier's synchronization point, they can reuse the same
   barrier.

   A barrier has a completion phase, which is executed by one of the participating
   threads once all threads in the set of participating threads arrive at the
   synchronization point. The arrive_and_wait and arrive_and_drop calls synchronize
   with the start of the completion phase; the end of the completion phase synchronizes
   with the returns from all calls blocked by its completion.

   std::experimental::flex_barrier allows the user to control the completion phase with
   a function object. If the function object returns -1, the set of participating
   threads is unchanged (and the same set of participating threads must arrive at the
   synchronization point in the next cycle); otherwise the set of participating threads
   becomes a new set with a size equal to the returned value N, and consists of the
   next N threads to arrive at the barrier's synchronization point.

   Users who do not need this functionality can use std::experimental::barrier.

.SH Member functions

   constructor     constructs a flex_barrier
                   \fI(public member function)\fP
   destructor      destroys the flex_barrier
                   \fI(public member function)\fP
   operator=       not copy-assignable
   [deleted]       \fI(public member function)\fP
   arrive_and_wait arrive at the synchronization point and block
                   \fI(public member function)\fP
                   arrive at the synchronization point and remove the current thread
   arrive_and_drop from the set of participating threads
                   \fI(public member function)\fP
