.TH std::errc 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::errc \- std::errc

.SH Synopsis
   Defined in header <system_error>
   enum class errc;                  \fI(since C++11)\fP

   The scoped enumeration std::errc defines the values of portable error conditions
   that correspond to the POSIX error codes.

.SH Member constants

   Constant                           Equivalent POSIX Error
   address_family_not_supported       EAFNOSUPPORT
   address_in_use                     EADDRINUSE
   address_not_available              EADDRNOTAVAIL
   already_connected                  EISCONN
   argument_list_too_long             E2BIG
   argument_out_of_domain             EDOM
   bad_address                        EFAULT
   bad_file_descriptor                EBADF
   bad_message                        EBADMSG
   broken_pipe                        EPIPE
   connection_aborted                 ECONNABORTED
   connection_already_in_progress     EALREADY
   connection_refused                 ECONNREFUSED
   connection_reset                   ECONNRESET
   cross_device_link                  EXDEV
   destination_address_required       EDESTADDRREQ
   device_or_resource_busy            EBUSY
   directory_not_empty                ENOTEMPTY
   executable_format_error            ENOEXEC
   file_exists                        EEXIST
   file_too_large                     EFBIG
   filename_too_long                  ENAMETOOLONG
   function_not_supported             ENOSYS
   host_unreachable                   EHOSTUNREACH
   identifier_removed                 EIDRM
   illegal_byte_sequence              EILSEQ
   inappropriate_io_control_operation ENOTTY
   interrupted                        EINTR
   invalid_argument                   EINVAL
   invalid_seek                       ESPIPE
   io_error                           EIO
   is_a_directory                     EISDIR
   message_size                       EMSGSIZE
   network_down                       ENETDOWN
   network_reset                      ENETRESET
   network_unreachable                ENETUNREACH
   no_buffer_space                    ENOBUFS
   no_child_process                   ECHILD
   no_link                            ENOLINK
   no_lock_available                  ENOLCK
   no_message_available \fB(deprecated)\fP  ENODATA
   no_message                         ENOMSG
   no_protocol_option                 ENOPROTOOPT
   no_space_on_device                 ENOSPC
   no_stream_resources \fB(deprecated)\fP   ENOSR
   no_such_device_or_address          ENXIO
   no_such_device                     ENODEV
   no_such_file_or_directory          ENOENT
   no_such_process                    ESRCH
   not_a_directory                    ENOTDIR
   not_a_socket                       ENOTSOCK
   not_a_stream \fB(deprecated)\fP          ENOSTR
   not_connected                      ENOTCONN
   not_enough_memory                  ENOMEM
   not_supported                      ENOTSUP
   operation_canceled                 ECANCELED
   operation_in_progress              EINPROGRESS
   operation_not_permitted            EPERM
   operation_not_supported            EOPNOTSUPP
   operation_would_block              EWOULDBLOCK
   owner_dead                         EOWNERDEAD
   permission_denied                  EACCES
   protocol_error                     EPROTO
   protocol_not_supported             EPROTONOSUPPORT
   read_only_file_system              EROFS
   resource_deadlock_would_occur      EDEADLK
   resource_unavailable_try_again     EAGAIN
   result_out_of_range                ERANGE
   state_not_recoverable              ENOTRECOVERABLE
   stream_timeout \fB(deprecated)\fP        ETIME
   text_file_busy                     ETXTBSY
   timed_out                          ETIMEDOUT
   too_many_files_open_in_system      ENFILE
   too_many_files_open                EMFILE
   too_many_links                     EMLINK
   too_many_symbolic_link_levels      ELOOP
   value_too_large                    EOVERFLOW
   wrong_protocol_type                EPROTOTYPE

.SH Non-member functions

   make_error_code(std::errc)      creates error code value for errc enum e
   \fI(C++11)\fP                         \fI(function)\fP
   make_error_condition(std::errc) creates an error condition for an errc value e
   \fI(C++11)\fP                         \fI(function)\fP

.SH Helper classes

                                      extends the type trait
   is_error_condition_enum<std::errc> std::is_error_condition_enum to identify errc
   \fI(C++11)\fP                            values as error conditions
                                      \fI(function template)\fP

.SH Example


// Run this code

 #include <filesystem>
 #include <fstream>
 #include <iomanip>
 #include <iostream>
 #include <string>
 #include <system_error>
 #include <thread>

 void print_error(const std::string& details, std::error_code error_code)
 {
     std::string value_name;
     if (error_code == std::errc::invalid_argument)
         value_name = "std::errc::invalid_argument";
     if (error_code == std::errc::no_such_file_or_directory)
         value_name = "std::errc::no_such_file_or_directory";
     if (error_code == std::errc::is_a_directory)
         value_name = "std::errc::is_a_directory";
     if (error_code == std::errc::permission_denied)
         value_name = "std::errc::permission_denied";

     std::cout << details << ":\\n  "
               << std::quoted(error_code.message())
               << " (" << value_name << ")\\n\\n";
 }

 void print_errno(const std::string& details, int errno_value = errno)
 {
     print_error(details, std::make_error_code(std::errc(errno_value)));
 }

 int main()
 {
     std::cout << "Detaching a not-a-thread...\\n";
     try
     {
         std::thread().detach();
     }
     catch (const std::system_error& e)
     {
         print_error("Error detaching empty thread", e.code());
     }

     std::cout << "Opening nonexistent file...\\n";
     std::ifstream nofile{"nonexistent-file"};
     if (!nofile.is_open())
         print_errno("Error opening nonexistent file for reading");

     std::cout << "Reading from directory as a file...\\n";
     std::filesystem::create_directory("dir");
     std::ifstream dir_stream{"dir"};
     [[maybe_unused]] char c = dir_stream.get();
     if (!dir_stream.good())
         print_errno("Error reading data from directory");

     std::cout << "Open read-only file for writing...\\n";
     std::fstream{"readonly-file", std::ios::out};
     std::filesystem::permissions("readonly-file", std::filesystem::perms::owner_read);
     std::fstream write_readonly("readonly-file", std::ios::out);
     if (!write_readonly.is_open())
         print_errno("Error opening read-only file for writing");
 }

.SH Possible output:

 Detaching a not-a-thread...
 Error detaching empty thread:
   "Invalid argument" (std::errc::invalid_argument)

 Opening nonexistent file...
 Error opening nonexistent file for reading:
   "No such file or directory" (std::errc::no_such_file_or_directory)

 Reading from directory as a file...
 Error reading data from directory:
   "Is a directory" (std::errc::is_a_directory)

 Open read-only file for writing...
 Error opening read-only file for writing:
   "Permission denied" (std::errc::permission_denied)

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to              Behavior as published              Correct behavior
                       the member constants no_message_available,
   LWG 3869 C++11      no_stream_resources, not_a_stream and           deprecated them
                       stream_timeout
                       referred to the obsolete POSIX STREAMS API^[1]

    1. â†‘ Although the corresponding POSIX error numbers ENODATA, ENOSR, ENOSTR and
       ETIME were marked "obsolescent" in POSIX 2017, the STREAMS API was optional and
       not required for conformance to the previous POSIX standard (because popular
       unix-like systems refused to implement it).

.SH See also

   error_code      holds a platform-dependent error code
   \fI(C++11)\fP         \fI(class)\fP
   error_condition holds a portable error code
   \fI(C++11)\fP         \fI(class)\fP
