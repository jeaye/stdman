.TH std::numeric_limits::max_digits10 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::max_digits10 \- std::numeric_limits::max_digits10

.SH Synopsis
   static constexpr int max_digits10  \fI(since C++11)\fP

   The value of std::numeric_limits<T>::max_digits10 is the number of base-10 digits
   that are necessary to uniquely represent all distinct values of the type T, such as
   necessary for serialization/deserialization to text. This constant is meaningful for
   all floating-point types.

.SH Standard specializations

   T                     value of std::numeric_limits<T>::max_digits10
   /* non-specialized */ 0
   bool                  0
   char                  0
   signed char           0
   unsigned char         0
   wchar_t               0
   char16_t              0
   char32_t              0
   short                 0
   unsigned short        0
   int                   0
   unsigned int          0
   long                  0
   unsigned long         0
   long long             0
   unsigned long long    0
                         FLT_DECIMAL_DIG or
   float                 std::ceil(std::numeric_limits<float>::digits * std::log10\fB(2)\fP +
                         1)
                         DBL_DECIMAL_DIG
   double                orstd::ceil(std::numeric_limits<double>::digits *
                         std::log10\fB(2)\fP + 1)
                         DECIMAL_DIG or LDBL_DECIMAL_DIG
   long double           orstd::ceil(std::numeric_limits<long double>::digits *
                         std::log10\fB(2)\fP + 1)

.SH Notes

   Unlike most mathematical operations, the conversion of a floating-point value to
   text and back is exact as long as at least max_digits10 were used (9 for float, 17
   for double): it is guaranteed to produce the same floating-point value, even though
   the intermediate text representation is not exact. It may take over a hundred
   decimal digits to represent the precise value of a float in decimal notation.

.SH Example

   
// Run this code

 #include <limits>
 #include <sstream>
 #include <iomanip>
 #include <cmath>
 #include <iostream>
  
 template< typename FloatingType >
 std::string to_string_scientific( FloatingType value, int precision )
 {
     std::ostringstream oss;
     oss << std::scientific << std::setprecision( precision ) << value;
     return oss.str();
 }
  
 template< typename FloatingType >
 constexpr int max_fractional_digits10()
 {
     constexpr auto max_digits10 = std::numeric_limits<FloatingType>::max_digits10;
     constexpr auto one_digit10_in_integer_part = 1;
     return max_digits10 - one_digit10_in_integer_part;
 }
  
 template< typename FloatingType >
 std::string to_string_complete( FloatingType value )
 {
     return to_string_scientific( value, max_fractional_digits10<FloatingType>() );
 }
  
 template< typename FloatingType >
 std::string to_string_incomplete( FloatingType value )
 {
     return to_string_scientific( value, max_fractional_digits10<FloatingType>() - 1 );
 }
  
 int main()
 {
     float f = 1.00000086e+01f;
  
     for( auto i = 0; i < 4; ++i )
     {
         std::cout
             << "incomplete: " << to_string_incomplete( f )
             << ", complete: " << to_string_complete( f )
             << '\\n';
  
         f = std::nextafter( f, std::numeric_limits<decltype(f)>::max() );
     }
 }

.SH Output:

 incomplete: 1.0000009e+01, complete: 1.00000086e+01
 incomplete: 1.0000010e+01, complete: 1.00000095e+01
 incomplete: 1.0000010e+01, complete: 1.00000105e+01
 incomplete: 1.0000011e+01, complete: 1.00000114e+01

.SH See also

   radix        the radix or integer base used by the representation of the given type
   \fB[static]\fP     \fI(public static member constant)\fP 
   digits       number of radix digits that can be represented without change
   \fB[static]\fP     \fI(public static member constant)\fP 
   digits10     number of decimal digits that can be represented without change
   \fB[static]\fP     \fI(public static member constant)\fP 
   min_exponent one more than the smallest negative power of the radix that is a valid
   \fB[static]\fP     normalized floating-point value
                \fI(public static member constant)\fP 
   max_exponent one more than the largest integer power of the radix that is a valid
   \fB[static]\fP     finite floating-point value
                \fI(public static member constant)\fP 
